[
    {
      "question_ko": "프로세스(Process)와 스레드(Thread)의 메모리 공유 모델에 대한 설명 중 옳은 것은?",
      "question_en": "Which statement is correct regarding the memory sharing model of Processes and Threads?",
      "hint_ko": "스레드는 '실행 흐름'입니다. 실행 흐름이 독립적이려면 무엇이 따로 필요할까요?",
      "hint_en": "A thread is an 'execution flow'. What does it need separately to be independent?",
      "topic": "operatingSystem",
      "difficulty": "easy",
      "concept": "Process vs Thread",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "스레드는 프로세스의 코드, 데이터, 힙 영역을 공유하지만, 스택과 레지스터는 독립적으로 가진다.",
          "text_en": "Threads share the process's code, data, and heap segments but maintain independent stacks and registers.",
          "rationale_ko": "스레드는 함수 호출 기록(스택)과 현재 실행 상태(레지스터/PC)를 독립적으로 가져야 별도의 제어 흐름을 유지할 수 있습니다. 나머지 자원은 효율성을 위해 공유합니다.",
          "rationale_en": "Threads must maintain independent function call histories (stack) and execution states (registers/PC) to have separate control flows. Other resources are shared for efficiency.",
          "isCorrect": true
        },
        {
          "text_ko": "스레드는 프로세스의 모든 메모리 영역(스택 포함)을 완벽하게 공유한다.",
          "text_en": "Threads share all memory segments of the process, including the stack.",
          "rationale_ko": "스택을 공유하면 함수 호출과 로컬 변수가 섞여 독립적인 실행이 불가능합니다.",
          "rationale_en": "Sharing the stack would mix function calls and local variables, making independent execution impossible.",
          "isCorrect": false
        },
        {
          "text_ko": "스레드는 자신만의 힙(Heap) 영역을 가지며 데이터 영역만 공유한다.",
          "text_en": "Threads have their own Heap segments and share only the Data segment.",
          "rationale_ko": "힙은 동적 할당 메모리로, 프로세스 내 모든 스레드가 공유하여 데이터 교환에 사용합니다.",
          "rationale_en": "The Heap is for dynamic allocation and is shared by all threads in the process for data exchange.",
          "isCorrect": false
        },
        {
          "text_ko": "멀티스레드 환경에서는 각 스레드가 독립적인 페이지 테이블을 가진다.",
          "text_en": "In a multithreaded environment, each thread has an independent page table.",
          "rationale_ko": "같은 프로세스 내의 스레드들은 동일한 주소 공간을 사용하므로 페이지 테이블을 공유합니다.",
          "rationale_en": "Threads within the same process use the same address space, so they share the page table.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "멀티스레딩(Multi-threading)은 항상 멀티프로세싱(Multi-processing)보다 효율적이고 우수하다.",
      "question_en": "Multi-threading is always more efficient and superior to Multi-processing.",
      "hint_ko": "한 스레드에서 치명적인 오류(예: Segmentation Fault)가 발생하면 프로세스 전체에 어떤 일이 생길까요?",
      "hint_en": "What happens to the entire process if a fatal error (e.g., Segmentation Fault) occurs in one thread?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Process vs Thread",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "스레드는 자원을 공유하므로 동기화 오버헤드가 발생하며, 하나의 스레드 장애가 프로세스 전체를 종료시킬 수 있어 안정성 면에서는 프로세스 격리가 더 유리할 수 있습니다.",
          "rationale_en": "Threads share resources, causing synchronization overhead. Also, a crash in one thread can terminate the entire process, so process isolation can be better for stability.",
          "isCorrect": true
        },
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "스레드 생성과 전환 비용이 적은 것은 사실이나, 안정성과 동기화 복잡성 때문에 '항상' 우수한 것은 아닙니다. 브라우저 탭 격리 등이 반례입니다.",
          "rationale_en": "While creation and switching costs are lower, stability and synchronization complexity mean it's not 'always' superior. Browser tab isolation is a counterexample.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "프로세스 상태 전이(Process State Transition) 모델에서 'Waiting(Blocked)' 상태의 프로세스가 I/O가 완료되면 즉시 'Running' 상태로 전이된다.",
      "question_en": "In the Process State Transition model, a process in the 'Waiting (Blocked)' state immediately transitions to 'Running' when I/O completes.",
      "hint_ko": "CPU는 현재 다른 프로세스가 사용 중일 수 있습니다. 순서를 기다려야 하지 않을까요?",
      "hint_en": "The CPU might currently be used by another process. Shouldn't it wait for its turn?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Process State Transition & PCB",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "I/O가 완료되면 프로세스는 'Ready' 큐로 이동하여 스케줄러의 선택을 기다려야 합니다. Running 상태로는 오직 스케줄러(Dispatcher)에 의해서만 전이될 수 있습니다.",
          "rationale_en": "Upon I/O completion, the process moves to the 'Ready' queue to wait for the scheduler. Transition to 'Running' occurs only via the scheduler (Dispatcher).",
          "isCorrect": true
        },
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "I/O 완료 인터럽트가 발생하면 즉시 CPU를 할당받는 것이 아니라, 준비 완료 상태가 되는 것입니다.",
          "rationale_en": "An I/O completion interrupt makes the process ready, but it doesn't grant CPU immediately.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "라운드 로빈(Round Robin) 스케줄링에서 타임 퀀텀(Time Quantum) 크기가 성능에 미치는 영향에 대한 설명 중 옳은 것은?",
      "question_en": "Which statement correctly describes the effect of Time Quantum size on performance in Round Robin scheduling?",
      "hint_ko": "퀀텀이 너무 작으면 배보다 배꼽(문맥 교환 비용)이 더 커질 수 있습니다.",
      "hint_en": "If the quantum is too small, the overhead (context switching cost) might exceed the actual work.",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Scheduling Algorithms (FCFS, SJF, RR, Priority, MLFQ)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "타임 퀀텀이 너무 작으면 문맥 교환(Context Switch) 오버헤드가 커져 전체 처리율이 떨어진다.",
          "text_en": "If the time quantum is too small, context switch overhead increases, reducing overall throughput.",
          "rationale_ko": "빈번한 문맥 교환은 CPU가 실제 작업을 하는 시간 비율을 줄입니다. 반대로 퀀텀이 너무 크면 FCFS와 비슷해져 응답 시간이 나빠집니다.",
          "rationale_en": "Frequent context switches reduce the ratio of useful CPU work. Conversely, if the quantum is too large, it behaves like FCFS, degrading response time.",
          "isCorrect": true
        },
        {
          "text_ko": "타임 퀀텀이 작을수록 문맥 교환 비용이 줄어들어 시스템 성능이 향상된다.",
          "text_en": "Smaller time quantum reduces context switching costs, improving system performance.",
          "rationale_ko": "퀀텀이 작으면 교환 횟수가 늘어나 비용이 증가합니다.",
          "rationale_en": "Smaller quantum increases the frequency of switches, raising costs.",
          "isCorrect": false
        },
        {
          "text_ko": "타임 퀀텀을 무한대로 설정하면 SJF(Shortest Job First)와 동일하게 동작한다.",
          "text_en": "Setting time quantum to infinity makes it behave identical to SJF (Shortest Job First).",
          "rationale_ko": "무한대 퀀텀은 선점을 하지 않으므로 FCFS(First-Come First-Served)와 동일하게 동작합니다.",
          "rationale_en": "Infinite quantum implies no preemption, behaving like FCFS (First-Come First-Served).",
          "isCorrect": false
        },
        {
          "text_ko": "타임 퀀텀 크기는 응답 시간(Response Time)에 전혀 영향을 주지 않는다.",
          "text_en": "Time quantum size has no effect on Response Time.",
          "rationale_ko": "RR은 응답 시간을 줄이기 위한 알고리즘이며, 퀀텀 크기는 이에 결정적입니다.",
          "rationale_en": "RR is designed to reduce response time, and quantum size is critical to it.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "공유 변수 `count`에 대해 두 스레드가 `count++`를 동시에 실행할 때 경쟁 조건(Race Condition)이 발생하는 이유는?",
      "question_en": "Why does a race condition occur when two threads concurrently execute `count++` on a shared variable `count`?",
      "hint_ko": "`count++`는 CPU 입장에서 한 번에 처리되는 명령어가 아닙니다. (Load -> Inc -> Store)",
      "hint_en": "`count++` is not a single instruction for the CPU. (Load -> Inc -> Store)",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Critical Section & Race Condition",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "`count++`가 원자적(Atomic) 연산이 아니어서, 값을 읽고(Load) 증가시켜 저장(Store)하는 도중에 문맥 교환이 일어날 수 있기 때문이다.",
          "text_en": "Because `count++` is not an atomic operation; a context switch can occur between loading, incrementing, and storing the value.",
          "rationale_ko": "기계어 수준에서 Load, Increment, Store 3단계로 분리되므로, 두 스레드가 동시에 Load를 하면 서로의 증가 연산을 덮어쓰게 되어 값이 1만 증가하는 결과가 생길 수 있습니다.",
          "rationale_en": "At the machine level, it splits into Load, Increment, Store. If both threads Load simultaneously, they overwrite each other's increment, potentially increasing the value by only 1.",
          "isCorrect": true
        },
        {
          "text_ko": "운영체제가 스레드의 메모리 접근 순서를 임의로 바꾸기 때문이다.",
          "text_en": "Because the OS arbitrarily reorders thread memory accesses.",
          "rationale_ko": "문제의 핵심은 원자성 부재입니다. 메모리 오더링 이슈도 있지만, `count++` 자체의 비원자성이 주원인입니다.",
          "rationale_en": "The core issue is lack of atomicity. While memory ordering matters, the non-atomicity of `count++` is the primary cause.",
          "isCorrect": false
        },
        {
          "text_ko": "스레드 간에는 전역 변수를 공유할 수 없기 때문이다.",
          "text_en": "Because global variables cannot be shared between threads.",
          "rationale_ko": "스레드는 전역 변수(데이터 영역)를 공유합니다.",
          "rationale_en": "Threads do share global variables (data segment).",
          "isCorrect": false
        },
        {
          "text_ko": "캐시 일관성(Cache Coherence) 하드웨어가 동작하지 않기 때문이다.",
          "text_en": "Because cache coherence hardware is not working.",
          "rationale_ko": "하드웨어가 정상이어도 논리적인 동기화(Lock 등) 없이는 경쟁 조건이 발생합니다.",
          "rationale_en": "Even with working hardware, race conditions occur without logical synchronization (like locks).",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "생산자-소비자(Producer-Consumer) 문제에서 세마포어를 사용할 때, `mutex.wait()`와 `empty.wait()` (또는 `full.wait()`)의 호출 순서를 바꾸면 발생할 수 있는 문제는?",
      "question_en": "In the Producer-Consumer problem using semaphores, what issue can arise if the calling order of `mutex.wait()` and `empty.wait()` (or `full.wait()`) is swapped?",
      "hint_ko": "화장실 열쇠(mutex)를 먼저 쥐고 들어갔는데, 휴지(buffer space)가 없어서 기다려야 한다면 어떻게 될까요?",
      "hint_en": "If you grab the restroom key (mutex) and enter, but realize there is no paper (buffer space) and have to wait inside, what happens?",
      "topic": "operatingSystem",
      "difficulty": "hard",
      "concept": "Semaphore",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "교착 상태(Deadlock)가 발생한다.",
          "text_en": "Deadlock occurs.",
          "rationale_ko": "생산자가 뮤텍스를 잡은 상태에서 빈 공간(`empty`)을 기다리며 잠들면, 소비자는 뮤텍스를 얻지 못해 데이터를 꺼낼 수 없고 빈 공간도 생기지 않아 영원히 대기하게 됩니다.",
          "rationale_en": "If the producer sleeps waiting for `empty` space while holding the mutex, the consumer cannot acquire the mutex to consume data, so no space is ever freed, causing indefinite waiting.",
          "isCorrect": true
        },
        {
          "text_ko": "기아 상태(Starvation)가 발생한다.",
          "text_en": "Starvation occurs.",
          "rationale_ko": "이는 특정 프로세스가 계속 밀리는 현상이며, 여기서는 아예 진행이 멈추는 데드락이 발생합니다.",
          "rationale_en": "Starvation implies getting delayed indefinitely, but here execution stops completely (deadlock).",
          "isCorrect": false
        },
        {
          "text_ko": "임계 구역 보호가 깨져 데이터가 손상된다.",
          "text_en": "Critical section protection fails, leading to data corruption.",
          "rationale_ko": "뮤텍스가 보호는 하지만, 순서 문제로 인해 진입 자체가 막혀버립니다.",
          "rationale_en": "The mutex protects, but the order issue blocks entry entirely.",
          "isCorrect": false
        },
        {
          "text_ko": "바쁜 대기(Busy Waiting)로 인해 CPU 사용률이 급증한다.",
          "text_en": "CPU usage spikes due to Busy Waiting.",
          "rationale_ko": "세마포어의 `wait` 연산은 일반적으로 프로세스를 대기 큐로 보내 잠재우므로(Sleep), CPU를 소모하지 않습니다.",
          "rationale_en": "Semaphore `wait` operations typically put the process to sleep in a queue, not consuming CPU.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "자원 할당 그래프(Resource Allocation Graph)에 사이클(Cycle)이 존재하면 반드시 데드락(Deadlock) 상태이다.",
      "question_en": "If a cycle exists in the Resource Allocation Graph, the system is necessarily in a Deadlock state.",
      "hint_ko": "자원 유형마다 인스턴스가 1개인 경우와 여러 개인 경우를 구분해야 합니다.",
      "hint_en": "Distinguish between cases where resource types have a single instance versus multiple instances.",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Deadlock",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "자원 인스턴스가 하나뿐이라면 사이클은 데드락을 의미하지만, 인스턴스가 여러 개(Multiple Instances)라면 사이클이 있어도 다른 프로세스가 자원을 반납하여 사이클을 깰 가능성이 있습니다.",
          "rationale_en": "With single instances, a cycle implies deadlock. However, with multiple instances, a cycle might be broken if another process releases a resource.",
          "isCorrect": true
        },
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "다중 인스턴스 자원에서는 사이클이 데드락의 필요조건일 뿐, 충분조건은 아닙니다.",
          "rationale_en": "For multi-instance resources, a cycle is a necessary condition for deadlock, but not a sufficient one.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "메모리 할당에서 외부 단편화(External Fragmentation)가 발생하는 주된 원인은?",
      "question_en": "What is the primary cause of External Fragmentation in memory allocation?",
      "hint_ko": "전체 빈 공간의 합은 충분한데, 이것들이 모여 있지 않다면 어떻게 될까요?",
      "hint_en": "If the sum of total free space is sufficient, but they are not gathered together, what happens?",
      "topic": "operatingSystem",
      "difficulty": "easy",
      "concept": "Contiguous Allocation & Fragmentation",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "가변 분할 다중 프로그래밍에서 메모리 할당과 해제가 반복되면서 작은 빈 공간(Hole)들이 산재하게 되기 때문이다.",
          "text_en": "Because repeated allocation and deallocation in variable partition multiprogramming scatter small free spaces (Holes).",
          "rationale_ko": "연속 할당 방식을 쓸 때, 총 여유 공간은 충분하지만 연속된 공간이 없어 프로세스를 할당하지 못하는 현상입니다. 페이징이 이를 해결합니다.",
          "rationale_en": "In contiguous allocation, total free space exists but is not contiguous, preventing allocation. Paging solves this.",
          "isCorrect": true
        },
        {
          "text_ko": "고정 크기 파티션 내부에 사용하지 않는 공간이 남기 때문이다.",
          "text_en": "Because unused space remains inside fixed-size partitions.",
          "rationale_ko": "이것은 내부 단편화(Internal Fragmentation)에 대한 설명입니다.",
          "rationale_en": "This describes Internal Fragmentation.",
          "isCorrect": false
        },
        {
          "text_ko": "페이지 테이블의 크기가 너무 커서 메모리를 낭비하기 때문이다.",
          "text_en": "Because the page table size is too large, wasting memory.",
          "rationale_ko": "이는 페이징 시스템의 오버헤드 문제이며, 단편화의 정의와 다릅니다.",
          "rationale_en": "This is overhead in paging systems, distinct from fragmentation definitions.",
          "isCorrect": false
        },
        {
          "text_ko": "가상 메모리가 물리 메모리보다 크기 때문이다.",
          "text_en": "Because virtual memory is larger than physical memory.",
          "rationale_ko": "이는 가상 메모리의 특징일 뿐 단편화의 원인이 아닙니다.",
          "rationale_en": "This is a feature of virtual memory, not a cause of fragmentation.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TLB(Translation Lookaside Buffer)를 도입했을 때 유효 메모리 접근 시간(EAT)을 줄일 수 있는 이유는?",
      "question_en": "Why does introducing a TLB (Translation Lookaside Buffer) reduce the Effective Memory Access Time (EAT)?",
      "hint_ko": "페이지 테이블은 어디에 저장되어 있나요? TLB가 없으면 메모리를 몇 번 가야 하나요?",
      "hint_en": "Where is the page table stored? Without a TLB, how many times must you access memory?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "TLB (Translation Lookaside Buffer)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "페이지 테이블이 메인 메모리에 있어 발생하는 2번의 메모리 접근(페이지 테이블 조회 + 데이터 접근)을 1번으로 줄여주기 때문이다.",
          "text_en": "Because it reduces the two memory accesses required (page table lookup + data access) since the page table resides in main memory, down to one.",
          "rationale_ko": "TLB는 고속 캐시로 주소 변환 정보를 저장합니다. TLB Hit 시 메모리 접근 없이 주소를 변환하여 데이터 접근 1회만 수행하면 됩니다.",
          "rationale_en": "TLB is a high-speed cache for address translations. On a TLB Hit, address translation happens without memory access, requiring only 1 data access.",
          "isCorrect": true
        },
        {
          "text_ko": "페이지 폴트(Page Fault) 발생 확률을 줄여주기 때문이다.",
          "text_en": "Because it reduces the probability of Page Faults.",
          "rationale_ko": "TLB는 주소 변환 속도를 높일 뿐, 페이지 부재(디스크 I/O) 확률과는 직접적인 관련이 적습니다.",
          "rationale_en": "TLB speeds up translation but has little direct impact on page fault (disk I/O) probability.",
          "isCorrect": false
        },
        {
          "text_ko": "더 큰 페이지 크기를 사용할 수 있게 해주기 때문이다.",
          "text_en": "Because it allows using larger page sizes.",
          "rationale_ko": "TLB는 페이지 크기와 무관하게 주소 변환을 캐싱합니다. (물론 Huge Page가 TLB 효율을 높이긴 합니다)",
          "rationale_en": "TLB caches translations regardless of page size. (Though Huge Pages do improve TLB efficiency).",
          "isCorrect": false
        },
        {
          "text_ko": "컨텍스트 스위칭 속도를 빠르게 해주기 때문이다.",
          "text_en": "Because it speeds up context switching.",
          "rationale_ko": "오히려 컨텍스트 스위칭 시 TLB를 플러시해야 해서 오버헤드가 될 수 있습니다(ASID 미사용 시).",
          "rationale_en": "Conversely, flushing TLB during context switches can add overhead (if ASID is not used).",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "Bélády의 모순(Bélády's Anomaly) 현상이 발생하는 페이지 교체 알고리즘은?",
      "question_en": "Which page replacement algorithm exhibits Bélády's Anomaly?",
      "hint_ko": "오래된 페이지를 무조건 내쫓는 단순한 알고리즘에서, 프레임 수를 늘렸는데 오히려 페이지 폴트가 늘어나는 현상입니다.",
      "hint_en": "A phenomenon where increasing frames increases page faults, happening in a simple algorithm that blindly evicts the oldest page.",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Page Replacement Algorithms",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "FIFO (First-In, First-Out)",
          "text_en": "FIFO (First-In, First-Out)",
          "rationale_ko": "FIFO는 페이지의 지역성(Locality)을 고려하지 않기 때문에, 프레임을 늘렸을 때 오히려 자주 쓰이는 페이지가 교체되는 패턴이 발생하여 성능이 나빠질 수 있습니다.",
          "rationale_en": "Since FIFO ignores locality, increasing frames can sometimes cause frequently used pages to be evicted, degrading performance.",
          "isCorrect": true
        },
        {
          "text_ko": "LRU (Least Recently Used)",
          "text_en": "LRU (Least Recently Used)",
          "rationale_ko": "LRU는 스택 알고리즘(Stack Algorithm)에 속하며, 프레임이 늘어나면 성능이 좋아지거나 같음이 수학적으로 보장됩니다.",
          "rationale_en": "LRU is a Stack Algorithm, mathematically guaranteed to improve or maintain performance as frames increase.",
          "isCorrect": false
        },
        {
          "text_ko": "Optimal (OPT)",
          "text_en": "Optimal (OPT)",
          "rationale_ko": "Optimal은 이론상 최적의 알고리즘으로 모순이 발생하지 않습니다.",
          "rationale_en": "Optimal is theoretically the best algorithm and does not suffer from the anomaly.",
          "isCorrect": false
        },
        {
          "text_ko": "LFU (Least Frequently Used)",
          "text_en": "LFU (Least Frequently Used)",
          "rationale_ko": "LFU도 빈도를 기반으로 하므로 일반적인 경우 모순이 발생하지 않는 편입니다(FIFO가 대표적 사례).",
          "rationale_en": "LFU is based on frequency and typically does not exhibit the anomaly (FIFO is the classic case).",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "쓰래싱(Thrashing)이 발생하여 시스템 성능이 급격히 저하될 때, 운영체제가 취해야 할 올바른 조치는?",
      "question_en": "What is the correct action for the OS to take when Thrashing causes a sharp decline in system performance?",
      "hint_ko": "CPU가 노는 이유가 '할 일이 없어서'가 아니라 '페이지를 가져오느라 바빠서'입니다. 일거리를 더 주어야 할까요, 줄여야 할까요?",
      "hint_en": "The CPU is idle not because of 'no work', but because it's 'busy fetching pages'. Should you add more work or reduce it?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Thrashing & Working Set Model",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "멀티프로그래밍의 정도(Degree of Multiprogramming)를 낮춘다.",
          "text_en": "Decrease the Degree of Multiprogramming.",
          "rationale_ko": "쓰래싱은 프로세스들이 필요한 최소한의 프레임도 갖지 못해 페이지 폴트만 처리하는 상태입니다. 일부 프로세스를 스왑 아웃(Swap Out)시켜 남은 프로세스들에게 충분한 메모리를 줘야 합니다.",
          "rationale_en": "Thrashing occurs when processes lack minimum frames and only handle faults. Swapping out some processes gives the remaining ones enough memory.",
          "isCorrect": true
        },
        {
          "text_ko": "더 많은 프로세스를 메모리에 적재하여 CPU 이용률을 높인다.",
          "text_en": "Load more processes into memory to increase CPU utilization.",
          "rationale_ko": "이는 상황을 악화시킵니다. CPU 이용률이 낮은 것은 I/O 대기 때문인데, 프로세스를 더 넣으면 페이지 폴트 경쟁이 심해집니다.",
          "rationale_en": "This worsens the situation. Low CPU utilization is due to I/O wait; adding processes increases contention for pages.",
          "isCorrect": false
        },
        {
          "text_ko": "디스크 스케줄링 알고리즘을 변경한다.",
          "text_en": "Change the disk scheduling algorithm.",
          "rationale_ko": "근본 원인은 메모리 부족이므로 디스크 최적화로는 해결되지 않습니다.",
          "rationale_en": "The root cause is memory shortage; disk optimization won't solve it.",
          "isCorrect": false
        },
        {
          "text_ko": "타임 퀀텀을 줄인다.",
          "text_en": "Decrease the time quantum.",
          "rationale_ko": "스케줄링 파라미터 변경은 메모리 과부하 문제와 무관합니다.",
          "rationale_en": "Changing scheduling parameters is irrelevant to memory overload issues.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "연결 할당(Linked Allocation) 기법과 비교했을 때, 인덱스 할당(Indexed Allocation) 기법의 가장 큰 장점은?",
      "question_en": "Compared to Linked Allocation, what is the biggest advantage of Indexed Allocation?",
      "hint_ko": "파일의 중간 부분(예: 500번째 블록)을 읽으려고 할 때, 연결 리스트는 어떻게 해야 하나요?",
      "hint_en": "When trying to read the middle of a file (e.g., 500th block), what must a linked list do?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "File Allocation Methods",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "파일의 임의 위치에 대한 직접 접근(Direct/Random Access)이 효율적이다.",
          "text_en": "Direct/Random Access to arbitrary file positions is efficient.",
          "rationale_ko": "인덱스 블록만 읽으면 원하는 블록의 위치를 바로 알 수 있어 O(1) 접근이 가능합니다. 반면 연결 할당은 순차적으로 따라가야 하므로 O(N)입니다.",
          "rationale_en": "Reading the index block reveals the target block location immediately, allowing O(1) access. Linked allocation requires sequential traversal, which is O(N).",
          "isCorrect": true
        },
        {
          "text_ko": "외부 단편화가 발생하지 않는다.",
          "text_en": "No External Fragmentation occurs.",
          "rationale_ko": "연결 할당도 외부 단편화는 없습니다(블록 단위 할당이므로).",
          "rationale_en": "Linked allocation also has no external fragmentation (due to block-based allocation).",
          "isCorrect": false
        },
        {
          "text_ko": "작은 파일에 대해 저장 공간 오버헤드가 적다.",
          "text_en": "Lower storage overhead for small files.",
          "rationale_ko": "인덱스 할당은 별도의 인덱스 블록을 써야 해서 작은 파일에는 오버헤드가 더 큽니다.",
          "rationale_en": "Indexed allocation requires a separate index block, causing higher overhead for small files.",
          "isCorrect": false
        },
        {
          "text_ko": "파일 크기 확장이 제한적이다.",
          "text_en": "File size expansion is limited.",
          "rationale_ko": "인덱스 블록 크기 한계가 있을 수 있지만, 다중 레벨 인덱스로 해결 가능하며 이는 장점이 아닙니다.",
          "rationale_en": "Index block size limits exist but can be solved with multi-level indexes; this is not an advantage.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "RAID 5 시스템에서 하나의 디스크가 고장 났을 때 데이터를 복구하는 원리는?",
      "question_en": "How does a RAID 5 system recover data when a single disk fails?",
      "hint_ko": "나머지 정상 디스크들의 데이터를 모두 XOR 연산하면 무엇이 나올까요?",
      "hint_en": "What happens if you XOR all the data from the remaining healthy disks?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "RAID Levels",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "나머지 정상 디스크들의 데이터와 패리티 블록을 XOR 연산하여 손실된 데이터를 재구성한다.",
          "text_en": "It reconstructs the lost data by XORing the data and parity blocks from the remaining healthy disks.",
          "rationale_ko": "RAID 5는 패리티 정보를 분산 저장합니다. A XOR B XOR C = P 일 때, C가 손실되면 A XOR B XOR P = C가 되는 XOR의 성질을 이용해 복구합니다.",
          "rationale_en": "RAID 5 distributes parity. Since A XOR B XOR C = P, if C is lost, A XOR B XOR P = C. It uses this XOR property to recover.",
          "isCorrect": true
        },
        {
          "text_ko": "미러링된 다른 디스크에서 데이터를 복사해 온다.",
          "text_en": "It copies data from a mirrored disk.",
          "rationale_ko": "이는 RAID 1(Mirroring)의 복구 방식입니다.",
          "rationale_en": "This is how RAID 1 (Mirroring) recovers.",
          "isCorrect": false
        },
        {
          "text_ko": "저널링 로그를 재실행하여 데이터를 복구한다.",
          "text_en": "It replays journaling logs to recover data.",
          "rationale_ko": "저널링은 파일 시스템의 논리적 복구이며, 물리적 디스크 고장 복구와는 다릅니다.",
          "rationale_en": "Journaling is for logical file system recovery, different from physical disk failure recovery.",
          "isCorrect": false
        },
        {
          "text_ko": "고장 난 디스크를 교체할 때까지 데이터 접근이 불가능하다.",
          "text_en": "Data access is impossible until the failed disk is replaced.",
          "rationale_ko": "RAID 5는 디스크 하나가 고장 나도 실시간으로 데이터를 재구성하여 서비스가 가능합니다(Degraded Mode).",
          "rationale_en": "RAID 5 allows service to continue by reconstructing data in real-time even with a failed disk (Degraded Mode).",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "시스템 콜(System Call)이 일반 함수 호출(Function Call)보다 비용이 큰 주된 이유는?",
      "question_en": "What is the main reason System Calls are more expensive than regular Function Calls?",
      "hint_ko": "단순히 코드로 점프하는 것이 아니라, 권한 수준(Privilege Level)이 바뀝니다.",
      "hint_en": "It's not just jumping to code; the Privilege Level changes.",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "User Mode vs Kernel Mode & System Calls",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "사용자 모드에서 커널 모드로의 전환(Mode Switch)과 그에 따른 문맥 저장/복원 오버헤드 때문이다.",
          "text_en": "Due to the Mode Switch from user to kernel mode and the associated context save/restore overhead.",
          "rationale_ko": "시스템 콜은 소프트웨어 인터럽트(Trap)를 발생시켜 모드 비트를 변경하고, 커널 스택으로 전환하며, 보안 검사를 수행해야 하므로 단순 점프보다 훨씬 무겁습니다.",
          "rationale_en": "System calls trigger a software interrupt (Trap), changing the mode bit, switching to kernel stack, and performing security checks, making them much heavier than a simple jump.",
          "isCorrect": true
        },
        {
          "text_ko": "시스템 콜 함수의 코드가 더 길고 복잡하기 때문이다.",
          "text_en": "Because the code of system call functions is longer and more complex.",
          "rationale_ko": "코드 복잡도보다는 모드 전환이라는 하드웨어적/구조적 비용이 주원인입니다.",
          "rationale_en": "The main cost is the hardware/structural overhead of mode switching, not just code complexity.",
          "isCorrect": false
        },
        {
          "text_ko": "시스템 콜은 항상 디스크 I/O를 동반하기 때문이다.",
          "text_en": "Because system calls always involve disk I/O.",
          "rationale_ko": "`getpid()` 같은 간단한 시스템 콜은 I/O 없이 정보만 반환하지만 여전히 모드 전환 비용이 듭니다.",
          "rationale_en": "Simple system calls like `getpid()` return info without I/O but still incur mode switch costs.",
          "isCorrect": false
        },
        {
          "text_ko": "시스템 콜은 단일 스레드로만 동작하기 때문이다.",
          "text_en": "Because system calls operate only in a single thread.",
          "rationale_ko": "커널은 멀티스레드 환경에서 동시 진입을 지원합니다.",
          "rationale_en": "Kernels support concurrent entry in multithreaded environments.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "컨테이너(Container) 기술이 가상 머신(Virtual Machine)과 구별되는 가장 큰 구조적 차이점은?",
      "question_en": "What is the biggest structural difference between Container technology and Virtual Machines?",
      "hint_ko": "각각의 인스턴스가 운영체제 커널(Kernel)을 따로 가지고 있나요?",
      "hint_en": "Does each instance have its own OS Kernel?",
      "topic": "operatingSystem",
      "difficulty": "medium",
      "concept": "Virtualization & Containers",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "VM은 게스트 OS를 별도로 실행하지만, 컨테이너는 호스트 OS의 커널을 공유하며 프로세스 수준에서 격리한다.",
          "text_en": "VMs run a separate Guest OS, while Containers share the Host OS kernel and isolate at the process level.",
          "rationale_ko": "이 차이로 인해 컨테이너는 훨씬 가볍고 부팅이 빠르지만, 커널 취약점에 의한 보안 격리 수준은 VM보다 낮을 수 있습니다.",
          "rationale_en": "This makes containers much lighter and faster to boot, but their security isolation against kernel vulnerabilities may be lower than VMs.",
          "isCorrect": true
        },
        {
          "text_ko": "컨테이너는 하이퍼바이저 위에서 동작하고 VM은 호스트 OS 위에서 동작한다.",
          "text_en": "Containers run on a hypervisor, while VMs run on the Host OS.",
          "rationale_ko": "반대이거나 틀린 설명입니다. VM이 하이퍼바이저를 사용하고, 컨테이너는 OS 엔진(예: Docker)을 사용합니다.",
          "rationale_en": "Opposite or incorrect. VMs use a hypervisor; containers use an OS engine (e.g., Docker).",
          "isCorrect": false
        },
        {
          "text_ko": "VM은 리눅스만 지원하지만 컨테이너는 모든 OS를 지원한다.",
          "text_en": "VMs support only Linux, while Containers support all OSes.",
          "rationale_ko": "VM은 OS 제약이 거의 없지만, 컨테이너는 호스트 커널에 의존하므로 OS 종속성이 더 큽니다.",
          "rationale_en": "VMs have few OS limits, but containers depend on the host kernel, implying higher OS dependency.",
          "isCorrect": false
        },
        {
          "text_ko": "컨테이너는 네트워크 격리를 제공하지 않는다.",
          "text_en": "Containers do not provide network isolation.",
          "rationale_ko": "컨테이너도 네트워크 네임스페이스를 통해 격리를 제공합니다.",
          "rationale_en": "Containers also provide isolation via network namespaces.",
          "isCorrect": false
        }
      ]
    }
  ]