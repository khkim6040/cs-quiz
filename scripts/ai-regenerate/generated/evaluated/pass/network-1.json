[
    {
      "question_ko": "OSI 7계층 모델의 프레젠테이션 계층(Presentation Layer)과 세션 계층(Session Layer)의 기능은 TCP/IP 모델의 어느 계층에서 주로 처리되는가?",
      "question_en": "In the TCP/IP model, which layer primarily handles the functions of the Presentation and Session layers from the OSI 7-layer model?",
      "hint_ko": "TCP/IP 모델은 OSI 모델보다 계층 수가 적으며, 상위 계층의 기능들을 하나로 통합했습니다.",
      "hint_en": "The TCP/IP model has fewer layers than the OSI model and combines upper-layer functions.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "OSI 7-Layer vs TCP/IP Model",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "응용 계층 (Application Layer)",
          "text_en": "Application Layer",
          "rationale_ko": "TCP/IP 모델은 OSI의 세션, 프레젠테이션, 응용 계층의 기능을 모두 응용 계층 하나로 통합하여 처리합니다. 데이터의 포맷팅, 암호화, 세션 관리 등은 애플리케이션 프로토콜(예: HTTP, TLS) 내에서 구현됩니다.",
          "rationale_en": "The TCP/IP model integrates the functions of the OSI Session, Presentation, and Application layers into a single Application Layer. Functions like data formatting, encryption, and session management are implemented within application protocols.",
          "isCorrect": true
        },
        {
          "text_ko": "전송 계층 (Transport Layer)",
          "text_en": "Transport Layer",
          "rationale_ko": "전송 계층은 종단 간 데이터 전송과 흐름/오류 제어를 담당하며, 데이터의 표현 형식이나 세션 관리와는 무관합니다.",
          "rationale_en": "The Transport layer is responsible for end-to-end data transmission and flow/error control, not for data representation or session management.",
          "isCorrect": false
        },
        {
          "text_ko": "인터넷 계층 (Internet Layer)",
          "text_en": "Internet Layer",
          "rationale_ko": "인터넷 계층은 패킷의 논리적 주소 지정과 라우팅을 담당합니다.",
          "rationale_en": "The Internet layer is responsible for logical addressing and routing of packets.",
          "isCorrect": false
        },
        {
          "text_ko": "네트워크 인터페이스 계층 (Network Interface Layer)",
          "text_en": "Network Interface Layer",
          "rationale_ko": "이 계층은 물리적 하드웨어와의 통신을 담당합니다.",
          "rationale_en": "This layer handles communication with physical hardware.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "라우터(Router)와 스위치(Switch)가 동작하는 계층과 처리하는 데이터 단위(PDU)가 올바르게 짝지어진 것은?",
      "question_en": "Which pair correctly matches the Router and Switch with their operating layers and Protocol Data Units (PDUs)?",
      "hint_ko": "라우터는 IP 주소를, 스위치는 MAC 주소를 주로 다룹니다.",
      "hint_en": "Routers primarily deal with IP addresses, while switches deal with MAC addresses.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "OSI 7-Layer vs TCP/IP Model",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "라우터 - 3계층 (패킷), 스위치 - 2계층 (프레임)",
          "text_en": "Router - Layer 3 (Packet), Switch - Layer 2 (Frame)",
          "rationale_ko": "라우터는 네트워크 계층(L3) 장비로 패킷(Packet)을 라우팅하며, 스위치는 데이터 링크 계층(L2) 장비로 프레임(Frame)을 스위칭합니다.",
          "rationale_en": "Routers are Network Layer (L3) devices that route Packets, while Switches are Data Link Layer (L2) devices that switch Frames.",
          "isCorrect": true
        },
        {
          "text_ko": "라우터 - 2계층 (프레임), 스위치 - 3계층 (패킷)",
          "text_en": "Router - Layer 2 (Frame), Switch - Layer 3 (Packet)",
          "rationale_ko": "라우터와 스위치의 역할이 뒤바뀌었습니다.",
          "rationale_en": "The roles of the router and switch are swapped.",
          "isCorrect": false
        },
        {
          "text_ko": "라우터 - 4계층 (세그먼트), 스위치 - 3계층 (패킷)",
          "text_en": "Router - Layer 4 (Segment), Switch - Layer 3 (Packet)",
          "rationale_ko": "라우터는 주로 3계층에서 동작하며, 4계층 세그먼트는 전송 계층의 단위입니다.",
          "rationale_en": "Routers operate primarily at Layer 3, and Segments are the unit of the Transport Layer.",
          "isCorrect": false
        },
        {
          "text_ko": "라우터 - 3계층 (프레임), 스위치 - 2계층 (패킷)",
          "text_en": "Router - Layer 3 (Frame), Switch - Layer 2 (Packet)",
          "rationale_ko": "계층은 맞지만 PDU 명칭이 서로 바뀌었습니다. 3계층은 패킷, 2계층은 프레임입니다.",
          "rationale_en": "The layers are correct, but the PDU names are swapped. Layer 3 uses Packets, and Layer 2 uses Frames.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TCP/IP 모델은 OSI 모델보다 계층 수가 적기 때문에 기능이 부족하고 단순한 모델이다.",
      "question_en": "The TCP/IP model is a simpler and functionally deficient model because it has fewer layers than the OSI model.",
      "hint_ko": "계층의 수가 적다고 해서 실제 제공하는 기능이 적은 것은 아닙니다.",
      "hint_en": "Fewer layers do not necessarily mean fewer provided functions.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "OSI 7-Layer vs TCP/IP Model",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "TCP/IP 모델은 계층을 통합했을 뿐 기능이 부족하지 않습니다. 오히려 실용적이고 구현 효율성이 높아 현대 인터넷의 표준이 되었습니다.",
          "rationale_en": "The TCP/IP model integrates layers but does not lack functionality. In fact, its practicality and implementation efficiency have made it the standard for the modern Internet.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "TCP/IP는 OSI 모델의 기능을 통합하여 효율적으로 구현한 모델이며, 계층 수의 차이가 기능의 유무를 의미하지는 않습니다.",
          "rationale_en": "TCP/IP efficiently implements the functions of the OSI model by integrating layers; the difference in the number of layers does not imply a lack of functionality.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "데이터 캡슐화(Encapsulation) 과정에서 헤더가 추가되는 올바른 순서는 무엇인가?",
      "question_en": "What is the correct order in which headers are added during the data encapsulation process?",
      "hint_ko": "데이터는 상위 계층에서 하위 계층으로 내려가며 포장됩니다.",
      "hint_en": "Data is wrapped as it moves from upper layers to lower layers.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "OSI 7-Layer vs TCP/IP Model",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "데이터 → TCP 헤더 → IP 헤더 → 이더넷 헤더",
          "text_en": "Data → TCP Header → IP Header → Ethernet Header",
          "rationale_ko": "응용 데이터에 전송 계층(TCP) 헤더가 붙어 세그먼트가 되고, 네트워크 계층(IP) 헤더가 붙어 패킷이 되며, 마지막으로 링크 계층(Ethernet) 헤더가 붙어 프레임이 됩니다.",
          "rationale_en": "Application data gets a Transport (TCP) header to become a segment, then a Network (IP) header to become a packet, and finally a Link (Ethernet) header to become a frame.",
          "isCorrect": true
        },
        {
          "text_ko": "데이터 → 이더넷 헤더 → IP 헤더 → TCP 헤더",
          "text_en": "Data → Ethernet Header → IP Header → TCP Header",
          "rationale_ko": "이는 디캡슐화(역캡슐화) 순서이거나 완전히 거꾸로 된 순서입니다.",
          "rationale_en": "This is either the order of decapsulation or completely reversed.",
          "isCorrect": false
        },
        {
          "text_ko": "데이터 → IP 헤더 → TCP 헤더 → 이더넷 헤더",
          "text_en": "Data → IP Header → TCP Header → Ethernet Header",
          "rationale_ko": "IP 헤더는 TCP 헤더의 바깥쪽에 붙어야 합니다. 전송 계층 처리가 먼저입니다.",
          "rationale_en": "The IP header must be attached outside the TCP header. Transport layer processing comes first.",
          "isCorrect": false
        },
        {
          "text_ko": "이더넷 헤더 → IP 헤더 → TCP 헤더 → 데이터",
          "text_en": "Ethernet Header → IP Header → TCP Header → Data",
          "rationale_ko": "물리적 프레임 구조상 헤더의 위치를 나열한 것일 수 있으나, '추가되는 순서'를 묻는 질문에는 상위 계층부터 나열해야 합니다.",
          "rationale_en": "While this lists header positions in a physical frame, the question asks for the 'order of addition', which starts from the upper layers.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "회선 교환(Circuit Switching) 방식에서 FDM(Frequency Division Multiplexing)과 TDM(Time Division Multiplexing)의 차이점은 무엇인가?",
      "question_en": "What is the difference between FDM (Frequency Division Multiplexing) and TDM (Time Division Multiplexing) in circuit switching?",
      "hint_ko": "하나는 주파수 대역을 나누고, 다른 하나는 시간을 나눕니다.",
      "hint_en": "One divides the frequency band, while the other divides time.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "Circuit Switching vs Packet Switching",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "FDM은 주파수 대역을 나누어 동시에 전송하고, TDM은 시간을 슬롯으로 나누어 번갈아 전송한다.",
          "text_en": "FDM splits the frequency band for simultaneous transmission, while TDM splits time into slots for alternating transmission.",
          "rationale_ko": "FDM은 가용 대역폭을 여러 주파수 채널로 분할하여 사용자가 전 시간 동안 특정 주파수를 점유하게 하며, TDM은 전체 대역폭을 사용하되 시간 슬롯을 할당받아 주기적으로 전송합니다.",
          "rationale_en": "FDM divides available bandwidth into frequency channels where users occupy a specific frequency for the entire time, whereas TDM uses the full bandwidth but assigns time slots for periodic transmission.",
          "isCorrect": true
        },
        {
          "text_ko": "FDM은 디지털 신호에만 사용되고, TDM은 아날로그 신호에만 사용된다.",
          "text_en": "FDM is used only for digital signals, while TDM is used only for analog signals.",
          "rationale_ko": "FDM은 아날로그 신호(라디오 등)에 주로 쓰였으나 디지털에도 가능하며, TDM은 디지털 전송(T1 라인 등)에 흔하지만 아날로그도 샘플링을 통해 가능합니다. 신호 타입이 절대적 기준은 아닙니다.",
          "rationale_en": "FDM was common for analog (like radio) but works for digital; TDM is common for digital (like T1 lines). Signal type is not the absolute distinction.",
          "isCorrect": false
        },
        {
          "text_ko": "TDM이 FDM보다 항상 더 넓은 대역폭을 제공한다.",
          "text_en": "TDM always provides more bandwidth than FDM.",
          "rationale_ko": "두 방식 모두 물리적 링크의 총 용량을 나누는 방법일 뿐, 방식 자체가 총 대역폭을 늘려주지는 않습니다.",
          "rationale_en": "Both are methods of dividing the physical link's capacity; neither method inherently increases the total bandwidth.",
          "isCorrect": false
        },
        {
          "text_ko": "FDM은 패킷 교환 방식이고 TDM은 회선 교환 방식이다.",
          "text_en": "FDM is a packet switching method, while TDM is a circuit switching method.",
          "rationale_ko": "둘 다 회선 교환 네트워크에서 링크 자원을 나누는 다중화 기술입니다.",
          "rationale_en": "Both are multiplexing techniques used to share link resources in circuit-switched networks.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "패킷 교환 네트워크에서 L비트 패킷을 R bps 속도의 링크를 통해 N개의 라우터를 거쳐 전송할 때, 저장 후 전달(Store-and-Forward) 방식으로 인한 총 전송 지연(Transmission Delay)은?",
      "question_en": "In a packet-switched network, when an L-bit packet is transmitted over links with rate R bps through N routers using store-and-forward, what is the total transmission delay?",
      "hint_ko": "소스 호스트와 N개의 라우터 각각에서 패킷을 전송해야 합니다.",
      "hint_en": "The packet must be transmitted by the source host and each of the N routers.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "Circuit Switching vs Packet Switching",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "(N + 1) * (L / R)",
          "text_en": "(N + 1) * (L / R)",
          "rationale_ko": "패킷은 소스에서 1번, 그리고 N개의 라우터에서 각각 1번씩 다시 전송되어야 하므로 총 N+1번의 전송 지연(L/R)이 발생합니다.",
          "rationale_en": "The packet is transmitted once from the source and once from each of the N routers, resulting in a total of N+1 transmission delays of (L/R).",
          "isCorrect": true
        },
        {
          "text_ko": "N * (L / R)",
          "text_en": "N * (L / R)",
          "rationale_ko": "소스 호스트에서의 첫 번째 전송을 누락했습니다. 총 홉(Hop) 수는 N+1입니다.",
          "rationale_en": "This misses the first transmission from the source host. The total number of hops is N+1.",
          "isCorrect": false
        },
        {
          "text_ko": "(L / R) + N",
          "text_en": "(L / R) + N",
          "rationale_ko": "차원이 맞지 않는 식입니다. 시간과 개수를 더할 수 없습니다.",
          "rationale_en": "Dimensionally incorrect; you cannot add time and a count.",
          "isCorrect": false
        },
        {
          "text_ko": "(N + 1) * L * R",
          "text_en": "(N + 1) * L * R",
          "rationale_ko": "전송 지연은 크기를 속도로 나누어야 합니다(L/R). 곱하면 안 됩니다.",
          "rationale_en": "Transmission delay is size divided by rate (L/R), not multiplied.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "패킷 교환 방식은 회선 교환 방식보다 항상 효율적이고 우수하다.",
      "question_en": "Packet switching is always more efficient and superior to circuit switching.",
      "hint_ko": "실시간 음성 통화(VoIP) 같은 경우를 생각해 보세요.",
      "hint_en": "Consider cases like real-time voice calls (VoIP).",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "Circuit Switching vs Packet Switching",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "패킷 교환은 통계적 다중화로 대역폭 효율이 높지만, 혼잡 시 지연이나 패킷 손실이 발생할 수 있어 엄격한 품질(QoS)이 요구되는 실시간 서비스에는 회선 교환이 더 안정적일 수 있습니다.",
          "rationale_en": "While packet switching offers high bandwidth efficiency via statistical multiplexing, congestion can cause delays or packet loss, making circuit switching potentially more stable for real-time services requiring strict QoS.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "패킷 교환은 자원을 공유하여 효율성을 높이지만, 보장된 전송률이 필요한 실시간 애플리케이션에서는 회선 교환의 전용 자원 할당이 더 유리할 수 있으므로 '항상' 우수하지는 않습니다.",
          "rationale_en": "Packet switching increases efficiency through resource sharing, but circuit switching's dedicated resource allocation can be better for real-time applications requiring guaranteed rates, so it is not 'always' superior.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "1Mbps 링크를 공유하는 사용자들의 활동 확률이 10%일 때, 패킷 교환(Packet Switching)이 회선 교환(Circuit Switching)보다 더 많은 사용자를 수용할 수 있는 이유는?",
      "question_en": "Why can packet switching support more users than circuit switching when users share a 1 Mbps link and have an activity probability of 10%?",
      "hint_ko": "모든 사용자가 동시에 데이터를 보내지는 않습니다.",
      "hint_en": "Not all users transmit data at the same time.",
      "topic": "computerNetworking",
      "difficulty": "hard",
      "concept": "Circuit Switching vs Packet Switching",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "통계적 다중화(Statistical Multiplexing) 효과 때문이다.",
          "text_en": "Due to the effect of Statistical Multiplexing.",
          "rationale_ko": "사용자가 드물게 활동(10%)하므로, 동시에 활동하는 사용자 수가 링크 용량을 초과할 확률이 매우 낮습니다. 이를 이용해 회선 교환의 고정 할당보다 더 많은 사용자를 수용하는 것을 통계적 다중화라고 합니다.",
          "rationale_en": "Since users are rarely active (10%), the probability of simultaneous active users exceeding link capacity is very low. Supporting more users than fixed allocation allows is called statistical multiplexing.",
          "isCorrect": true
        },
        {
          "text_ko": "패킷 교환이 전송 속도를 동적으로 높여주기 때문이다.",
          "text_en": "Because packet switching dynamically increases transmission speed.",
          "rationale_ko": "패킷 교환이 물리적 링크 속도(1Mbps) 자체를 높여주지는 않습니다.",
          "rationale_en": "Packet switching does not increase the physical link speed (1 Mbps) itself.",
          "isCorrect": false
        },
        {
          "text_ko": "회선 교환은 헤더 오버헤드가 더 크기 때문이다.",
          "text_en": "Because circuit switching has larger header overhead.",
          "rationale_ko": "오히려 패킷 교환이 패킷마다 헤더를 붙이므로 오버헤드가 더 큽니다. 회선 교환은 초기 설정 후에는 헤더 없이 데이터만 보낼 수 있습니다.",
          "rationale_en": "Packet switching actually has higher overhead due to per-packet headers. Circuit switching can send raw data without headers after initial setup.",
          "isCorrect": false
        },
        {
          "text_ko": "패킷 교환은 데이터를 압축하여 보내기 때문이다.",
          "text_en": "Because packet switching compresses data before sending.",
          "rationale_ko": "압축은 교환 방식의 본질적인 차이가 아니라 상위 계층의 기능입니다.",
          "rationale_en": "Compression is a function of upper layers, not an intrinsic difference of the switching method.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "다음 중 종단 간 지연(End-to-End Delay)을 구성하는 요소가 아닌 것은?",
      "question_en": "Which of the following is NOT a component of End-to-End Delay?",
      "hint_ko": "지연은 처리, 큐잉, 전송, 전파 지연의 합입니다.",
      "hint_en": "Delay is the sum of processing, queuing, transmission, and propagation delays.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "End-to-End Delay Analysis",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "컴파일 지연 (Compilation Delay)",
          "text_en": "Compilation Delay",
          "rationale_ko": "컴파일 지연은 소스 코드를 기계어로 번역하는 시간으로, 네트워크 전송 지연 요소(처리, 큐잉, 전송, 전파)에 포함되지 않습니다.",
          "rationale_en": "Compilation delay is the time to translate source code to machine code and is not part of network transmission delay components (processing, queuing, transmission, propagation).",
          "isCorrect": true
        },
        {
          "text_ko": "전송 지연 (Transmission Delay)",
          "text_en": "Transmission Delay",
          "rationale_ko": "패킷의 모든 비트를 링크로 밀어내는 데 걸리는 시간입니다 (L/R).",
          "rationale_en": "Time required to push all bits of the packet onto the link (L/R).",
          "isCorrect": false
        },
        {
          "text_ko": "전파 지연 (Propagation Delay)",
          "text_en": "Propagation Delay",
          "rationale_ko": "신호가 물리 매체를 타고 건너편까지 도달하는 데 걸리는 시간입니다 (d/s).",
          "rationale_en": "Time required for the signal to travel across the physical medium to the other side (d/s).",
          "isCorrect": false
        },
        {
          "text_ko": "큐잉 지연 (Queuing Delay)",
          "text_en": "Queuing Delay",
          "rationale_ko": "라우터의 버퍼에서 처리를 기다리는 시간입니다.",
          "rationale_en": "Time spent waiting in the router's buffer for processing.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "대역폭(Bandwidth)을 10배로 늘리면 패킷의 전파 지연(Propagation Delay)도 1/10로 줄어든다.",
      "question_en": "Increasing the bandwidth by 10 times reduces the packet's propagation delay to 1/10.",
      "hint_ko": "전파 지연은 물리적 거리와 신호 속도에 의존합니다.",
      "hint_en": "Propagation delay depends on physical distance and signal speed.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "End-to-End Delay Analysis",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "대역폭을 늘리면 '전송 지연(Transmission Delay)'은 줄어들지만, '전파 지연'은 빛의 속도와 거리에 의해 결정되므로 변하지 않습니다. 흔한 오개념입니다.",
          "rationale_en": "Increasing bandwidth reduces 'Transmission Delay', but 'Propagation Delay' remains unchanged as it is determined by the speed of light and distance. This is a common misconception.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "전파 지연은 거리 / 신호 속도 (d/s)로 계산되며, 링크의 대역폭(bps)과는 무관합니다. 대역폭 증가는 패킷을 밀어넣는 시간을 단축시킬 뿐입니다.",
          "rationale_en": "Propagation delay is calculated as distance / signal speed (d/s) and is independent of link bandwidth (bps). Increasing bandwidth only shortens the time to push the packet onto the link.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "HTTP/1.1의 Head-of-Line (HOL) Blocking 문제는 무엇이며, HTTP/2는 이를 어떻게 해결했는가?",
      "question_en": "What is the Head-of-Line (HOL) Blocking problem in HTTP/1.1, and how did HTTP/2 solve it?",
      "hint_ko": "HTTP/1.1은 요청을 순차적으로 처리해야 하지만, HTTP/2는 스트림을 사용합니다.",
      "hint_en": "HTTP/1.1 must process requests sequentially, but HTTP/2 uses streams.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "HTTP/1.1 vs HTTP/2 vs HTTP/3",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "HTTP/1.1은 요청을 순서대로 응답해야 해서 앞선 처리가 늦어지면 뒤도 막히지만, HTTP/2는 멀티플렉싱(Multiplexing)으로 동시 전송을 지원하여 이를 해결했다.",
          "text_en": "HTTP/1.1 requires responses in order, causing delays if the first one stalls, but HTTP/2 solves this with multiplexing, allowing simultaneous transmission.",
          "rationale_ko": "HTTP/1.1의 파이프라이닝은 응답 순서를 지켜야 하는 한계가 있었으나, HTTP/2는 하나의 TCP 연결 내에서 여러 스트림을 프레임 단위로 쪼개어 순서에 상관없이 전송(Multiplexing)함으로써 애플리케이션 레벨의 HOL Blocking을 해결했습니다.",
          "rationale_en": "HTTP/1.1 pipelining was limited by response order requirements, but HTTP/2 solved application-level HOL blocking by breaking multiple streams into frames and transmitting them out of order (Multiplexing) over a single TCP connection.",
          "isCorrect": true
        },
        {
          "text_ko": "HTTP/1.1은 매번 새로운 TCP 연결을 맺어야 했지만, HTTP/2는 영구적 연결(Persistent Connection)을 도입하여 해결했다.",
          "text_en": "HTTP/1.1 had to establish a new TCP connection every time, but HTTP/2 solved this by introducing Persistent Connections.",
          "rationale_ko": "영구적 연결은 HTTP/1.1에서도 이미 기본값(Default)으로 지원됩니다. HOL Blocking은 연결 재사용 여부가 아니라 요청 처리 순서 문제입니다.",
          "rationale_en": "Persistent connections are already the default in HTTP/1.1. HOL blocking is about request processing order, not connection reuse.",
          "isCorrect": false
        },
        {
          "text_ko": "HTTP/1.1은 텍스트 기반이라 느렸지만, HTTP/2는 바이너리 프로토콜이라서 해결되었다.",
          "text_en": "HTTP/1.1 was slow because it was text-based, but HTTP/2 solved it by being a binary protocol.",
          "rationale_ko": "바이너리 포맷은 파싱 효율을 높여주지만, HOL Blocking 문제의 직접적인 해결책은 아닙니다.",
          "rationale_en": "Binary formatting improves parsing efficiency but is not the direct solution to the HOL blocking problem.",
          "isCorrect": false
        },
        {
          "text_ko": "HTTP/2는 UDP를 도입하여 TCP의 신뢰성 검사를 생략함으로써 해결했다.",
          "text_en": "HTTP/2 solved it by adopting UDP to skip TCP's reliability checks.",
          "rationale_ko": "HTTP/2는 여전히 TCP를 사용합니다. UDP를 도입한 것은 HTTP/3 (QUIC)입니다.",
          "rationale_en": "HTTP/2 still uses TCP. It is HTTP/3 (QUIC) that adopted UDP.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "HTTP/3는 UDP 기반의 QUIC 프로토콜을 사용하므로, 데이터 전송의 신뢰성(Reliability)을 보장하지 않는다.",
      "question_en": "Since HTTP/3 uses the UDP-based QUIC protocol, it does not guarantee reliability of data transmission.",
      "hint_ko": "UDP 위에서 동작한다고 해서 신뢰성을 포기한 것은 아닙니다. 누가 신뢰성을 책임지는지 생각해 보세요.",
      "hint_en": "Running over UDP doesn't mean giving up reliability. Think about who is responsible for reliability.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "HTTP/1.1 vs HTTP/2 vs HTTP/3",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "QUIC은 UDP를 사용하지만, 프로토콜 내부에서 패킷 재전송, 순서 정렬, 혼잡 제어 등을 직접 구현하여 TCP 수준의 신뢰성을 보장합니다. UDP라고 무조건 비신뢰적인 것은 아닙니다.",
          "rationale_en": "Although QUIC uses UDP, it implements packet retransmission, ordering, and congestion control internally to guarantee TCP-level reliability. UDP usage does not inherently imply unreliability.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "HTTP/3의 QUIC 계층이 UDP 위에서 신뢰성 있는 전송을 자체적으로 구현하므로, 애플리케이션 입장에서는 신뢰성이 보장됩니다.",
          "rationale_en": "The QUIC layer in HTTP/3 implements reliable transmission on top of UDP, so reliability is guaranteed from the application's perspective.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "DNS 질의 과정에서 '재귀적 질의(Recursive Query)'와 '반복적 질의(Iterative Query)'의 차이점은 무엇인가?",
      "question_en": "What is the difference between 'Recursive Query' and 'Iterative Query' in the DNS resolution process?",
      "hint_ko": "누가 최종 정답을 찾아올 책임을 지는지에 따라 다릅니다.",
      "hint_en": "It depends on who is responsible for finding the final answer.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "DNS Resolution Process",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "재귀적 질의는 요청받은 서버가 최종 답을 찾아와야 하고, 반복적 질의는 다음 서버의 힌트(참조)만 알려준다.",
          "text_en": "In a recursive query, the requested server must fetch the final answer, whereas in an iterative query, it only provides a hint (referral) to the next server.",
          "rationale_ko": "재귀적 질의에서는 로컬 DNS 서버가 클라이언트 대신 끝까지 답을 찾아옵니다. 반면 반복적 질의에서는 상위 DNS 서버가 '나는 모르니 여기(다음 서버)로 가보라'며 참조 정보를 줍니다.",
          "rationale_en": "In a recursive query, the local DNS server fetches the final answer for the client. In an iterative query, the upstream DNS server responds with a referral ('I don't know, ask this next server').",
          "isCorrect": true
        },
        {
          "text_ko": "재귀적 질의는 UDP를 사용하고, 반복적 질의는 TCP를 사용한다.",
          "text_en": "Recursive queries use UDP, while iterative queries use TCP.",
          "rationale_ko": "질의 방식과 전송 프로토콜(UDP/TCP)은 독립적입니다. DNS는 주로 UDP를 사용합니다.",
          "rationale_en": "The query method and transport protocol (UDP/TCP) are independent. DNS primarily uses UDP.",
          "isCorrect": false
        },
        {
          "text_ko": "재귀적 질의는 항상 루트 DNS 서버에게만 보낸다.",
          "text_en": "Recursive queries are always sent only to root DNS servers.",
          "rationale_ko": "클라이언트는 주로 로컬 DNS 서버에게 재귀적 질의를 보냅니다.",
          "rationale_en": "Clients primarily send recursive queries to their local DNS server.",
          "isCorrect": false
        },
        {
          "text_ko": "반복적 질의가 재귀적 질의보다 서버 부하가 더 크다.",
          "text_en": "Iterative queries put more load on the server than recursive queries.",
          "rationale_ko": "재귀적 질의는 서버가 답을 찾을 때까지 계속 작업해야 하므로 서버 부하가 더 큽니다.",
          "rationale_en": "Recursive queries impose more load on the server because it must continue working until it finds the answer.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TCP 소켓 프로그래밍에서 서버가 클라이언트의 연결 요청을 대기하기 위해 호출하는 함수들의 올바른 순서는?",
      "question_en": "What is the correct sequence of function calls for a TCP server to wait for client connection requests?",
      "hint_ko": "소켓을 생성하고, 주소를 붙이고, 듣기 시작해서, 받아들입니다.",
      "hint_en": "Create socket, bind address, start listening, and accept.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "Socket Programming & Client-Server Model",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "socket() → bind() → listen() → accept()",
          "text_en": "socket() → bind() → listen() → accept()",
          "rationale_ko": "소켓 생성(socket), IP/Port 결합(bind), 연결 대기열 생성(listen), 연결 수락(accept) 순서가 정석입니다.",
          "rationale_en": "The standard sequence is: create socket (socket), bind IP/Port (bind), create backlog queue (listen), and accept connection (accept).",
          "isCorrect": true
        },
        {
          "text_ko": "socket() → listen() → bind() → accept()",
          "text_en": "socket() → listen() → bind() → accept()",
          "rationale_ko": "어느 포트에서 들을지 정하지 않고(bind 전) listen을 할 수 없습니다.",
          "rationale_en": "You cannot listen without specifying which port to listen on (before bind).",
          "isCorrect": false
        },
        {
          "text_ko": "socket() → connect() → accept()",
          "text_en": "socket() → connect() → accept()",
          "rationale_ko": "connect()는 클라이언트가 호출하는 함수입니다.",
          "rationale_en": "connect() is a function called by the client.",
          "isCorrect": false
        },
        {
          "text_ko": "socket() → bind() → accept() → listen()",
          "text_en": "socket() → bind() → accept() → listen()",
          "rationale_ko": "대기열을 만들지 않고(listen 전) 연결을 수락(accept)할 수 없습니다.",
          "rationale_en": "You cannot accept a connection without creating a backlog queue (before listen).",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "SMTP, IMAP, POP3 프로토콜의 역할에 대한 설명 중 틀린 것은?",
      "question_en": "Which statement about the roles of SMTP, IMAP, and POP3 protocols is INCORRECT?",
      "hint_ko": "누가 메일을 보내고, 누가 메일을 가져오는지 구분해 보세요.",
      "hint_en": "Distinguish between who sends email and who retrieves email.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "Email Protocols (SMTP, IMAP, POP3)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "SMTP는 클라이언트가 메일 서버에서 이메일을 다운로드할 때 사용한다.",
          "text_en": "SMTP is used by clients to download emails from the mail server.",
          "rationale_ko": "SMTP는 메일을 '전송(Push)'하는 프로토콜입니다. 메일을 서버에서 가져오기(Pull) 위해서는 IMAP이나 POP3를 사용해야 합니다. 이것이 오답인 진술입니다.",
          "rationale_en": "SMTP is a 'Push' protocol for sending mail. To retrieve ('Pull') mail from a server, IMAP or POP3 must be used. This statement is incorrect.",
          "isCorrect": true
        },
        {
          "text_ko": "IMAP은 메일을 서버에 보관하고 여러 기기에서 상태를 동기화한다.",
          "text_en": "IMAP keeps emails on the server and synchronizes status across multiple devices.",
          "rationale_ko": "맞는 설명입니다. IMAP은 서버 기반 저장을 지원합니다.",
          "rationale_en": "Correct. IMAP supports server-based storage.",
          "isCorrect": false
        },
        {
          "text_ko": "POP3는 메일을 로컬로 다운로드하고 서버에서 삭제하는 것이 기본 동작이다.",
          "text_en": "POP3's default behavior is to download emails locally and delete them from the server.",
          "rationale_ko": "맞는 설명입니다. POP3는 'download-and-delete' 모델을 주로 사용했습니다.",
          "rationale_en": "Correct. POP3 traditionally uses the 'download-and-delete' model.",
          "isCorrect": false
        },
        {
          "text_ko": "SMTP는 메일 서버 간(MTA to MTA)의 메일 전송에도 사용된다.",
          "text_en": "SMTP is also used for mail transfer between mail servers (MTA to MTA).",
          "rationale_ko": "맞는 설명입니다. SMTP는 클라이언트 전송뿐만 아니라 서버 간 릴레이에도 사용됩니다.",
          "rationale_en": "Correct. SMTP is used for both client submission and inter-server relay.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TCP 3-way Handshake 과정에서 초기 시퀀스 번호(Initial Sequence Number, ISN)를 무작위(Random) 값으로 설정하는 주된 이유는?",
      "question_en": "What is the primary reason for setting the Initial Sequence Number (ISN) to a random value during the TCP 3-way Handshake?",
      "hint_ko": "예측 가능하면 보안상 어떤 문제가 생길지 생각해 보세요.",
      "hint_en": "Think about the security implications if it were predictable.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "TCP 3-Way Handshake & Connection Management",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "TCP 시퀀스 예측 공격(Sequence Prediction Attack)을 방지하기 위해서",
          "text_en": "To prevent TCP Sequence Prediction Attacks",
          "rationale_ko": "ISN이 예측 가능하면 공격자가 3-way handshake를 보지 않고도 위조된 패킷을 보내 연결을 가로채거나(hijacking) RST를 보내 끊을 수 있습니다.",
          "rationale_en": "If the ISN is predictable, attackers can send forged packets to hijack the connection or send RST to terminate it without seeing the 3-way handshake.",
          "isCorrect": true
        },
        {
          "text_ko": "TCP 헤더의 크기를 줄이기 위해서",
          "text_en": "To reduce the size of the TCP header",
          "rationale_ko": "ISN 값의 내용과 헤더 크기(32비트 필드)는 무관합니다.",
          "rationale_en": "The content of the ISN value implies nothing about the header size (32-bit field).",
          "isCorrect": false
        },
        {
          "text_ko": "네트워크 혼잡을 줄이기 위해서",
          "text_en": "To reduce network congestion",
          "rationale_ko": "시퀀스 번호의 값 자체는 혼잡 제어 알고리즘과 직접적인 관련이 없습니다.",
          "rationale_en": "The value of the sequence number itself is not directly related to congestion control algorithms.",
          "isCorrect": false
        },
        {
          "text_ko": "서버의 메모리 사용량을 줄이기 위해서",
          "text_en": "To reduce the server's memory usage",
          "rationale_ko": "랜덤 값 생성은 메모리 사용량 절감과 관련이 없습니다.",
          "rationale_en": "Random value generation is not related to memory usage reduction.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TCP의 Go-Back-N (GBN) 프로토콜에서 송신 윈도우 크기(N)와 시퀀스 번호 공간 크기(M) 사이에 지켜야 할 조건은?",
      "question_en": "What is the required condition between the sender window size (N) and the sequence number space size (M) in TCP's Go-Back-N (GBN) protocol?",
      "hint_ko": "윈도우가 너무 크면 수신자가 새 패킷인지 재전송 패킷인지 구분할 수 없습니다.",
      "hint_en": "If the window is too large, the receiver cannot distinguish between a new packet and a retransmission.",
      "topic": "computerNetworking",
      "difficulty": "hard",
      "concept": "TCP Reliable Data Transfer (ARQ)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "N < M",
          "text_en": "N < M",
          "rationale_ko": "GBN에서는 윈도우 크기 N이 시퀀스 번호 공간 M보다 작아야(N <= M-1) 모호성 문제가 발생하지 않습니다. SR(Selective Repeat)은 N <= M/2 입니다.",
          "rationale_en": "In GBN, the window size N must be smaller than the sequence number space M (N <= M-1) to avoid ambiguity. For SR (Selective Repeat), it is N <= M/2.",
          "isCorrect": true
        },
        {
          "text_ko": "N > M",
          "text_en": "N > M",
          "rationale_ko": "윈도우가 시퀀스 공간보다 크면 시퀀스 번호가 겹쳐서 데이터 무결성이 깨집니다.",
          "rationale_en": "If the window is larger than the sequence space, sequence numbers will overlap, breaking data integrity.",
          "isCorrect": false
        },
        {
          "text_ko": "N = M",
          "text_en": "N = M",
          "rationale_ko": "N=M이면 모든 ACK가 유실되었을 때, 송신자가 재전송한 패킷 0번을 수신자는 다음 주기의 새 패킷 0번으로 오해할 수 있습니다.",
          "rationale_en": "If N=M, if all ACKs are lost, the receiver might mistake a retransmitted packet 0 for a new packet 0 of the next cycle.",
          "isCorrect": false
        },
        {
          "text_ko": "N과 M은 관계가 없다",
          "text_en": "N and M are unrelated",
          "rationale_ko": "ARQ 프로토콜의 정확성을 위해 두 값은 밀접한 관계가 있습니다.",
          "rationale_en": "The two values are closely related for the correctness of ARQ protocols.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TCP 혼잡 제어(Congestion Control)에서 'Slow Start' 단계에 대한 설명으로 옳은 것은?",
      "question_en": "Which statement correctly describes the 'Slow Start' phase in TCP Congestion Control?",
      "hint_ko": "이름은 'Slow'지만 실제 속도 증가 양상을 생각해 보세요.",
      "hint_en": "The name is 'Slow', but think about the actual rate of speed increase.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "TCP Congestion Control (AIMD, Slow Start, Fast Recovery)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "혼잡 윈도우(cwnd) 크기가 지수적(Exponential)으로 증가한다.",
          "text_en": "The Congestion Window (cwnd) size increases exponentially.",
          "rationale_ko": "Slow Start는 1 MSS에서 시작하지만, 매 RTT마다 윈도우 크기가 2배씩 증가하므로 실제로는 매우 빠르게 증가합니다. 'Slow'는 시작점이 낮다는 의미일 뿐입니다.",
          "rationale_en": "Slow Start begins at 1 MSS, but the window size doubles every RTT, so it actually increases very quickly. 'Slow' only refers to the low starting point.",
          "isCorrect": true
        },
        {
          "text_ko": "혼잡 윈도우(cwnd) 크기가 선형적(Linear)으로 증가한다.",
          "text_en": "The Congestion Window (cwnd) size increases linearly.",
          "rationale_ko": "선형 증가는 혼잡 회피(Congestion Avoidance) 단계의 특징입니다.",
          "rationale_en": "Linear increase is a characteristic of the Congestion Avoidance phase.",
          "isCorrect": false
        },
        {
          "text_ko": "패킷 손실이 발생할 때까지 전송 속도를 일정하게 유지한다.",
          "text_en": "It maintains a constant transmission rate until packet loss occurs.",
          "rationale_ko": "TCP는 가용 대역폭을 찾기 위해 계속해서 윈도우를 늘립니다.",
          "rationale_en": "TCP continuously increases the window to probe for available bandwidth.",
          "isCorrect": false
        },
        {
          "text_ko": "항상 1kbps의 아주 느린 속도로 시작해서 절대 빨라지지 않는다.",
          "text_en": "It always starts at a very slow speed of 1kbps and never speeds up.",
          "rationale_ko": "Slow Start는 가용 대역폭을 빠르게 탐색하기 위한 과정이므로 속도는 급격히 빨라집니다.",
          "rationale_en": "Slow Start is a process to quickly probe available bandwidth, so the speed increases rapidly.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "CIDR(Classless Inter-Domain Routing) 표기법으로 192.168.10.0/24 네트워크를 4개의 동일한 크기 서브넷으로 나눌 때, 올바른 서브넷 마스크 길이는?",
      "question_en": "When dividing a 192.168.10.0/24 network into 4 equal-sized subnets using CIDR notation, what is the correct subnet mask length?",
      "hint_ko": "4개의 서브넷을 만들기 위해 몇 비트가 추가로 필요한지 계산해 보세요.",
      "hint_en": "Calculate how many additional bits are needed to create 4 subnets.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "IPv4 Addressing & Subnetting (CIDR)",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "/26",
          "text_en": "/26",
          "rationale_ko": "4개의 서브넷을 만들려면 2비트(2^2=4)를 호스트 파트에서 빌려와야 합니다. 기존 /24에 2비트를 더하면 /26이 됩니다.",
          "rationale_en": "To create 4 subnets, you need to borrow 2 bits (2^2=4) from the host part. Adding 2 bits to the existing /24 results in /26.",
          "isCorrect": true
        },
        {
          "text_ko": "/25",
          "text_en": "/25",
          "rationale_ko": "/25는 2개의 서브넷만 생성할 수 있습니다.",
          "rationale_en": "/25 can only create 2 subnets.",
          "isCorrect": false
        },
        {
          "text_ko": "/28",
          "text_en": "/28",
          "rationale_ko": "/28은 16개(2^4)의 서브넷을 생성합니다.",
          "rationale_en": "/28 creates 16 (2^4) subnets.",
          "isCorrect": false
        },
        {
          "text_ko": "/22",
          "text_en": "/22",
          "rationale_ko": "/22는 슈퍼네팅(Supernetting) 방향으로, 네트워크를 더 크게 합치는 것입니다.",
          "rationale_en": "/22 is in the direction of Supernetting, merging networks into a larger one.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "NAT(Network Address Translation)가 P2P(Peer-to-Peer) 애플리케이션이나 서버 운영에 문제를 일으키는 근본적인 이유는?",
      "question_en": "What is the fundamental reason NAT (Network Address Translation) causes problems for P2P applications or server operations?",
      "hint_ko": "외부에서 내부로 접속하려 할 때 주소를 알 수 있나요?",
      "hint_en": "Can the address be known when trying to connect from outside to inside?",
      "topic": "computerNetworking",
      "difficulty": "hard",
      "concept": "NAT (Network Address Translation)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "End-to-End 원칙을 위반하여 외부에서 내부 호스트로 직접 연결을 시작할 수 없기 때문이다.",
          "text_en": "Because it violates the End-to-End principle, preventing direct connection initiation from outside to inside hosts.",
          "rationale_ko": "NAT 뒤에 있는 호스트는 사설 IP를 가지므로 외부에서 직접 주소를 지정할 수 없습니다. 이로 인해 외부의 요청을 받아야 하는 서버나 P2P 통신에 'NAT Traversal' 기술이 필요합니다.",
          "rationale_en": "Hosts behind NAT have private IPs and cannot be directly addressed from outside. This necessitates 'NAT Traversal' techniques for servers or P2P communications that need to receive external requests.",
          "isCorrect": true
        },
        {
          "text_ko": "NAT 장비가 패킷을 암호화하여 내용을 볼 수 없게 만들기 때문이다.",
          "text_en": "Because NAT devices encrypt packets, making the content unreadable.",
          "rationale_ko": "NAT는 주소 변환만 수행하며 암호화와는 무관합니다.",
          "rationale_en": "NAT only performs address translation and is unrelated to encryption.",
          "isCorrect": false
        },
        {
          "text_ko": "NAT를 사용하면 인터넷 속도가 절반으로 줄어들기 때문이다.",
          "text_en": "Because using NAT reduces internet speed by half.",
          "rationale_ko": "NAT 처리 오버헤드는 존재하지만 속도가 절반이 되는 것은 아닙니다.",
          "rationale_en": "There is NAT processing overhead, but it does not halve the speed.",
          "isCorrect": false
        },
        {
          "text_ko": "NAT는 TCP 프로토콜만 지원하고 UDP는 지원하지 않기 때문이다.",
          "text_en": "Because NAT only supports TCP protocol and not UDP.",
          "rationale_ko": "NAT는 TCP, UDP, ICMP 등 다양한 프로토콜을 지원합니다.",
          "rationale_en": "NAT supports various protocols including TCP, UDP, and ICMP.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "링크 상태(Link-State) 라우팅 알고리즘(예: OSPF)에서 사용하는 알고리즘은 무엇인가?",
      "question_en": "Which algorithm is used in Link-State routing protocols (e.g., OSPF)?",
      "hint_ko": "가장 짧은 경로를 찾는 유명한 알고리즘입니다.",
      "hint_en": "It's a famous algorithm for finding the shortest path.",
      "topic": "computerNetworking",
      "difficulty": "easy",
      "concept": "Link-State Routing (Dijkstra / OSPF)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "다익스트라(Dijkstra) 알고리즘",
          "text_en": "Dijkstra's Algorithm",
          "rationale_ko": "링크 상태 라우팅은 전체 네트워크 토폴로지 정보를 모은 후, 다익스트라 알고리즘을 실행하여 최단 경로 트리를 구성합니다.",
          "rationale_en": "Link-State routing collects the entire network topology information and then runs Dijkstra's algorithm to build the shortest path tree.",
          "isCorrect": true
        },
        {
          "text_ko": "벨만-포드(Bellman-Ford) 알고리즘",
          "text_en": "Bellman-Ford Algorithm",
          "rationale_ko": "벨만-포드 알고리즘은 거리 벡터(Distance-Vector) 라우팅(예: RIP)에서 사용됩니다.",
          "rationale_en": "The Bellman-Ford algorithm is used in Distance-Vector routing (e.g., RIP).",
          "isCorrect": false
        },
        {
          "text_ko": "스패닝 트리(Spanning Tree) 알고리즘",
          "text_en": "Spanning Tree Algorithm",
          "rationale_ko": "스패닝 트리는 L2 스위치에서 루프를 방지하기 위해 사용됩니다.",
          "rationale_en": "Spanning Tree is used in L2 switches to prevent loops.",
          "isCorrect": false
        },
        {
          "text_ko": "플로이드-워셜(Floyd-Warshall) 알고리즘",
          "text_en": "Floyd-Warshall Algorithm",
          "rationale_ko": "모든 쌍 최단 경로 알고리즘으로, 일반적인 라우팅 프로토콜에서는 계산 복잡도 때문에 잘 사용되지 않습니다.",
          "rationale_en": "An all-pairs shortest path algorithm, rarely used in standard routing protocols due to computational complexity.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "이더넷의 CSMA/CD 방식에서 충돌(Collision)을 감지하기 위해 필요한 최소 프레임 크기 조건은?",
      "question_en": "What is the minimum frame size requirement to detect collisions in Ethernet's CSMA/CD?",
      "hint_ko": "프레임을 다 보내기 전에 신호가 왕복하고 돌아와야 충돌을 알 수 있습니다.",
      "hint_en": "The signal must travel round-trip and return before the frame finishes sending to detect a collision.",
      "topic": "computerNetworking",
      "difficulty": "hard",
      "concept": "Ethernet & CSMA/CD",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "전송 시간(Transmission Time) >= 2 * 전파 지연(Propagation Delay)",
          "text_en": "Transmission Time >= 2 * Propagation Delay",
          "rationale_ko": "가장 멀리 있는 노드에서 충돌이 발생하고 그 신호가 되돌아올 때까지(RTT) 송신자가 계속 전송 중이어야 충돌을 감지할 수 있습니다. 따라서 프레임 크기가 일정 수준 이상이어야 합니다.",
          "rationale_en": "The sender must still be transmitting when the collision signal returns from the farthest node (RTT) to detect the collision. Thus, the frame size must be above a certain threshold.",
          "isCorrect": true
        },
        {
          "text_ko": "전송 시간(Transmission Time) <= 전파 지연(Propagation Delay)",
          "text_en": "Transmission Time <= Propagation Delay",
          "rationale_ko": "이 경우 충돌 신호가 도달하기 전에 전송이 끝나버려, 송신자는 전송이 성공한 것으로 착각하게 됩니다.",
          "rationale_en": "In this case, transmission would finish before the collision signal arrives, causing the sender to mistakenly believe the transmission was successful.",
          "isCorrect": false
        },
        {
          "text_ko": "프레임 크기는 1500바이트 이상이어야 한다.",
          "text_en": "Frame size must be at least 1500 bytes.",
          "rationale_ko": "1500바이트는 최대 전송 단위(MTU)입니다. 최소 프레임 크기는 보통 64바이트입니다.",
          "rationale_en": "1500 bytes is the Maximum Transmission Unit (MTU). The minimum frame size is typically 64 bytes.",
          "isCorrect": false
        },
        {
          "text_ko": "전송 속도와 상관없이 1비트만 보내도 된다.",
          "text_en": "Sending just 1 bit is enough regardless of transmission speed.",
          "rationale_ko": "1비트는 너무 짧아서 전파 지연 동안 전송을 유지할 수 없습니다.",
          "rationale_en": "1 bit is too short to maintain transmission during the propagation delay.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "ARP Spoofing 공격은 네트워크의 어떤 취약점을 악용하는가?",
      "question_en": "What vulnerability in the network does an ARP Spoofing attack exploit?",
      "hint_ko": "ARP 요청을 받지 않아도 응답을 보낼 수 있나요?",
      "hint_en": "Can you send a response even if you didn't receive an ARP request?",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "Network Attack Types (DDoS, ARP Spoofing, DNS Poisoning)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "ARP 프로토콜의 인증 부재 (Stateless & Unauthenticated)",
          "text_en": "Lack of authentication in ARP protocol (Stateless & Unauthenticated)",
          "rationale_ko": "ARP는 요청에 대한 검증 없이 응답(Gratuitous ARP)을 수락하고 테이블을 갱신합니다. 공격자는 이를 이용해 라우터나 다른 호스트인 척 속일 수 있습니다.",
          "rationale_en": "ARP accepts responses (Gratuitous ARP) and updates tables without verification. Attackers exploit this to impersonate routers or other hosts.",
          "isCorrect": true
        },
        {
          "text_ko": "TCP 핸드셰이크의 취약점",
          "text_en": "Vulnerability in TCP handshake",
          "rationale_ko": "ARP는 2계층(Data Link) 프로토콜이며, TCP(4계층) 핸드셰이크와는 무관합니다.",
          "rationale_en": "ARP is a Layer 2 protocol and is unrelated to the TCP (Layer 4) handshake.",
          "isCorrect": false
        },
        {
          "text_ko": "DNS 서버의 재귀적 질의 허용",
          "text_en": "Allowing recursive queries on DNS servers",
          "rationale_ko": "이는 DNS Amplification 공격이나 Cache Poisoning과 관련이 있습니다.",
          "rationale_en": "This is related to DNS Amplification attacks or Cache Poisoning.",
          "isCorrect": false
        },
        {
          "text_ko": "IP 단편화 재조립 버퍼 오버플로우",
          "text_en": "IP fragmentation reassembly buffer overflow",
          "rationale_ko": "이는 Teardrop 공격 등 DoS 공격의 일종입니다.",
          "rationale_en": "This is a type of DoS attack, such as the Teardrop attack.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "WiFi(802.11) 네트워크에서 'Hidden Terminal Problem'은 무엇이며, 이를 해결하기 위한 기법은?",
      "question_en": "What is the 'Hidden Terminal Problem' in WiFi (802.11) networks, and what technique is used to solve it?",
      "hint_ko": "서로 보이지 않는 두 단말이 하나의 AP에 동시에 전송하려 할 때 발생합니다.",
      "hint_en": "Occurs when two terminals that cannot see each other try to transmit to the same AP simultaneously.",
      "topic": "computerNetworking",
      "difficulty": "medium",
      "concept": "WiFi (802.11) & CSMA/CA",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "두 노드가 서로 감지하지 못해 동시에 전송하여 충돌하는 문제이며, RTS/CTS(Request to Send / Clear to Send)로 해결한다.",
          "text_en": "Two nodes transmit simultaneously causing collision because they cannot detect each other; solved by RTS/CTS (Request to Send / Clear to Send).",
          "rationale_ko": "A와 C가 서로 거리가 멀어 전파를 감지 못할 때, 둘 다 B에게 데이터를 보내면 충돌이 납니다. RTS/CTS를 통해 B가 채널 예약 사실을 알리면 충돌을 막을 수 있습니다.",
          "rationale_en": "If A and C are too far apart to detect each other, transmitting to B simultaneously causes collision. RTS/CTS allows B to announce channel reservation, preventing collision.",
          "isCorrect": true
        },
        {
          "text_ko": "AP가 숨겨져서 접속하지 못하는 문제이며, SSID 브로드캐스팅으로 해결한다.",
          "text_en": "The AP is hidden and inaccessible; solved by SSID broadcasting.",
          "rationale_ko": "이는 Hidden SSID 설정에 관한 내용으로, Hidden Terminal 충돌 문제와는 다릅니다.",
          "rationale_en": "This refers to Hidden SSID settings, which is different from the Hidden Terminal collision problem.",
          "isCorrect": false
        },
        {
          "text_ko": "무선 신호가 벽을 통과하지 못하는 문제이며, 중계기(Repeater)로 해결한다.",
          "text_en": "Wireless signals cannot pass through walls; solved by repeaters.",
          "rationale_ko": "이는 신호 감쇠 문제(Signal Attenuation)입니다.",
          "rationale_en": "This is a signal attenuation problem.",
          "isCorrect": false
        },
        {
          "text_ko": "데이터 암호화가 안 되는 문제이며, WPA3로 해결한다.",
          "text_en": "Data encryption failure; solved by WPA3.",
          "rationale_ko": "이는 보안 문제입니다.",
          "rationale_en": "This is a security issue.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "BGP(Border Gateway Protocol)에서 경로를 선택할 때 가장 우선순위가 높은 기준은?",
      "question_en": "What is the highest priority criterion when selecting a path in BGP (Border Gateway Protocol)?",
      "hint_ko": "BGP는 기술적 효율성보다 관리자의 정책(Policy)을 더 중시합니다.",
      "hint_en": "BGP prioritizes administrative policy over technical efficiency.",
      "topic": "computerNetworking",
      "difficulty": "hard",
      "concept": "BGP (Border Gateway Protocol)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "Local Preference (LOCAL_PREF)",
          "text_en": "Local Preference (LOCAL_PREF)",
          "rationale_ko": "BGP 경로 선택 과정에서 LOCAL_PREF는 가장 먼저 고려되는 속성으로, AS 내부에서 어떤 외부 경로를 선호할지 관리자가 설정한 정책 값이 최우선입니다.",
          "rationale_en": "In BGP path selection, LOCAL_PREF is the first attribute considered. The policy value set by the administrator for preferred outbound paths within the AS takes highest precedence.",
          "isCorrect": true
        },
        {
          "text_ko": "AS Path Length (가장 짧은 AS 경로)",
          "text_en": "AS Path Length (Shortest AS path)",
          "rationale_ko": "AS Path 길이는 LOCAL_PREF 다음으로 고려되는 요소입니다.",
          "rationale_en": "AS Path Length is considered after LOCAL_PREF.",
          "isCorrect": false
        },
        {
          "text_ko": "MED (Multi-Exit Discriminator)",
          "text_en": "MED (Multi-Exit Discriminator)",
          "rationale_ko": "MED는 AS Path보다 낮은 우선순위를 가집니다.",
          "rationale_en": "MED has lower priority than AS Path.",
          "isCorrect": false
        },
        {
          "text_ko": "라우터 ID (Router ID)",
          "text_en": "Router ID",
          "rationale_ko": "라우터 ID는 모든 조건이 같을 때 마지막에 타이 브레이커로 사용됩니다.",
          "rationale_en": "Router ID is used as a final tie-breaker when all other conditions are equal.",
          "isCorrect": false
        }
      ]
    }
  ]