[
    {
      "question_ko": "AES-256이 AES-128보다 무차별 대입 공격(brute force)에 대해서는 더 안전하지만, 부채널 공격(side-channel attack)에 대해서는 반드시 더 안전하지는 않은 이유는 무엇인가?",
      "question_en": "Why is AES-256 more secure than AES-128 against brute force attacks, but not necessarily more secure against side-channel attacks?",
      "hint_ko": "키 길이가 암호 알고리즘의 수학적 강도에 미치는 영향과, 실제 구현 과정에서 발생하는 물리적 정보 유출의 차이를 생각해보세요.",
      "hint_en": "Consider how key length affects the mathematical strength of the algorithm versus how physical information leakage occurs during actual implementation.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Symmetric Encryption - Key length vs implementation security",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "무차별 대입 공격은 키 공간의 크기(2^128 vs 2^256)에 의존하지만, 부채널 공격은 암호화 연산 중 발생하는 타이밍, 전력 소비, 전자기 방출 등 구현 수준의 물리적 특성을 악용하므로 키 길이와 무관하다.",
          "text_en": "Brute force attacks depend on key space size (2^128 vs 2^256), but side-channel attacks exploit implementation-level physical characteristics like timing, power consumption, and electromagnetic emissions during cryptographic operations, which are independent of key length.",
          "rationale_ko": "정답입니다. 무차별 대입 공격의 복잡도는 키 공간 크기에 지수적으로 증가하므로 AES-256(2^256)이 AES-128(2^128)보다 훨씬 안전합니다. 그러나 부채널 공격은 S-box 조회, 메모리 접근 패턴, 분기 예측 등 실제 하드웨어/소프트웨어 구현의 물리적 부산물을 측정하여 키를 유추합니다. 키가 길어도 구현이 동일한 부채널 취약점(예: 캐시 타이밍 공격)을 가지면 동일하게 취약할 수 있습니다.",
          "rationale_en": "Correct. Brute force attack complexity increases exponentially with key space size, making AES-256 (2^256) far more secure than AES-128 (2^128). However, side-channel attacks measure physical byproducts of actual hardware/software implementation—such as S-box lookups, memory access patterns, and branch prediction—to infer the key. Even with a longer key, if the implementation has the same side-channel vulnerabilities (e.g., cache-timing attacks), it remains equally vulnerable.",
          "isCorrect": true
        },
        {
          "text_ko": "AES-256은 더 많은 라운드(14 vs 10)를 사용하므로 부채널 공격 시 측정해야 할 연산이 많아져서 실제로는 더 안전하다.",
          "text_en": "AES-256 uses more rounds (14 vs 10), so there are more operations to measure during side-channel attacks, making it actually more secure.",
          "rationale_ko": "오답입니다. 학생이 더 많은 라운드가 부채널 공격을 어렵게 만든다고 생각할 수 있지만, 실제로는 반대입니다. 더 많은 라운드는 공격자에게 더 많은 측정 기회를 제공할 수 있으며, 각 라운드의 키 스케줄 연산은 여전히 동일한 부채널 취약점을 노출합니다. 예를 들어, 차등 전력 분석(DPA)에서 더 많은 라운드는 더 많은 전력 소비 트레이스를 제공하여 오히려 공격을 용이하게 할 수 있습니다.",
          "rationale_en": "Incorrect. Students might think more rounds make side-channel attacks harder, but the opposite can be true. More rounds provide attackers with more measurement opportunities, and each round's key schedule operations still expose the same side-channel vulnerabilities. For example, in Differential Power Analysis (DPA), more rounds provide more power consumption traces, potentially facilitating the attack rather than hindering it.",
          "isCorrect": false
        },
        {
          "text_ko": "부채널 공격은 암호문을 분석하는 공격이므로 키 길이가 길수록 암호문이 복잡해져서 AES-256이 더 안전하다.",
          "text_en": "Side-channel attacks analyze ciphertext, so longer keys produce more complex ciphertext, making AES-256 more secure.",
          "rationale_ko": "오답입니다. 학생이 부채널 공격을 암호 분석(cryptanalysis)과 혼동하고 있습니다. 부채널 공격은 암호문 자체를 분석하는 것이 아니라, 암호화/복호화 과정 중 시스템이 물리적으로 방출하는 정보(전력, 시간, 소리, 열 등)를 측정합니다. 따라서 암호문의 복잡도나 키 길이는 부채널 공격의 성공 여부와 직접적인 관련이 없습니다. 예를 들어, AES-128과 AES-256 모두 동일한 S-box를 사용하므로 캐시 타이밍 공격에 대해 유사한 취약성을 보입니다.",
          "rationale_en": "Incorrect. The student is confusing side-channel attacks with cryptanalysis. Side-channel attacks do not analyze the ciphertext itself but measure physical information (power, timing, sound, heat, etc.) emitted by the system during encryption/decryption. Therefore, ciphertext complexity or key length has no direct relation to side-channel attack success. For example, both AES-128 and AES-256 use the same S-boxes, showing similar vulnerability to cache-timing attacks.",
          "isCorrect": false
        },
        {
          "text_ko": "AES-256은 하드웨어 가속(AES-NI)을 사용할 수 없어서 소프트웨어로 구현할 때 부채널 공격에 더 취약하다.",
          "text_en": "AES-256 cannot use hardware acceleration (AES-NI), making it more vulnerable to side-channel attacks when implemented in software.",
          "rationale_ko": "오답입니다. 이것은 사실이 아닙니다. AES-NI(Intel의 하드웨어 AES 명령어 세트)는 AES-128, AES-192, AES-256을 모두 지원합니다. 학생이 하드웨어 가속 지원을 키 길이와 연관 짓는 오해를 하고 있습니다. 실제로 AES-NI는 상수 시간(constant-time) 연산을 제공하여 타이밍 부채널 공격을 완화하는 데 도움이 되며, 이는 모든 AES 키 길이에 동일하게 적용됩니다.",
          "rationale_en": "Incorrect. This is factually wrong. AES-NI (Intel's hardware AES instruction set) supports AES-128, AES-192, and AES-256 equally. The student is mistakenly associating hardware acceleration support with key length. In fact, AES-NI provides constant-time operations that help mitigate timing side-channel attacks, and this applies equally to all AES key lengths.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "ECB 모드와 CBC 모드에서 동일한 두 개의 평문 블록을 암호화할 때 각각 어떤 일이 발생하는가?",
      "question_en": "What happens when two identical plaintext blocks are encrypted in ECB mode versus CBC mode?",
      "hint_ko": "각 블록 암호화 모드에서 이전 블록의 암호문이나 초기화 벡터가 현재 블록의 암호화에 어떤 영향을 미치는지 생각해보세요.",
      "hint_en": "Consider how the previous block's ciphertext or initialization vector affects the encryption of the current block in each cipher mode.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Symmetric Encryption - ECB vs CBC mode",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "ECB 모드에서는 동일한 암호문 블록이 생성되지만, CBC 모드에서는 이전 블록의 암호문(또는 IV)과 XOR되므로 서로 다른 암호문 블록이 생성된다.",
          "text_en": "In ECB mode, identical ciphertext blocks are produced, but in CBC mode, different ciphertext blocks are produced because each block is XORed with the previous ciphertext block (or IV).",
          "rationale_ko": "정답입니다. ECB(Electronic Codebook) 모드는 각 평문 블록을 독립적으로 암호화하므로 P1 = P2이면 C1 = C2가 됩니다. 이는 패턴 누출의 원인이 됩니다(예: 동일한 픽셀 색상이 동일한 암호문으로 나타나 이미지의 윤곽이 보임). 반면 CBC(Cipher Block Chaining) 모드는 C_i = E(P_i ⊕ C_{i-1})로 계산되므로, 동일한 평문 블록이라도 이전 암호문 블록과 XOR되어 서로 다른 암호문을 생성합니다. 이는 CBC가 의미론적 보안(semantic security)을 제공하는 이유입니다.",
          "rationale_en": "Correct. ECB (Electronic Codebook) mode encrypts each plaintext block independently, so if P1 = P2, then C1 = C2. This causes pattern leakage (e.g., identical pixel colors appear as identical ciphertext, revealing image outlines). In contrast, CBC (Cipher Block Chaining) mode computes C_i = E(P_i ⊕ C_{i-1}), so even identical plaintext blocks produce different ciphertext because they are XORed with the previous ciphertext block. This is why CBC provides semantic security.",
          "isCorrect": true
        },
        {
          "text_ko": "두 모드 모두 동일한 암호문 블록을 생성하지만, CBC 모드는 IV를 사용하므로 전체 암호문은 다르다.",
          "text_en": "Both modes produce identical ciphertext blocks, but CBC mode uses an IV so the overall ciphertext is different.",
          "rationale_ko": "오답입니다. 학생이 IV의 역할을 오해하고 있습니다. CBC 모드에서 IV는 첫 번째 블록 암호화 시에만 사용됩니다(C_1 = E(P_1 ⊕ IV)). 중요한 점은 동일한 평문 블록이 문서의 서로 다른 위치에 나타날 때, CBC는 체이닝 효과로 인해 서로 다른 암호문을 생성한다는 것입니다. 예를 들어, P_5 = P_10이어도 C_4와 C_9가 다르면 C_5 ≠ C_10입니다. 반면 ECB는 위치와 무관하게 항상 동일한 암호문을 생성합니다.",
          "rationale_en": "Incorrect. The student misunderstands the role of the IV. In CBC mode, the IV is only used for encrypting the first block (C_1 = E(P_1 ⊕ IV)). The key point is that when identical plaintext blocks appear at different positions in a document, CBC produces different ciphertext due to the chaining effect. For example, even if P_5 = P_10, if C_4 ≠ C_9, then C_5 ≠ C_10. In contrast, ECB always produces identical ciphertext regardless of position.",
          "isCorrect": false
        },
        {
          "text_ko": "ECB 모드에서는 서로 다른 암호문이 생성되고, CBC 모드에서는 동일한 암호문이 생성된다.",
          "text_en": "ECB mode produces different ciphertext blocks, while CBC mode produces identical ciphertext blocks.",
          "rationale_ko": "오답입니다. 이것은 정반대입니다. 학생이 두 모드의 작동 방식을 혼동하고 있습니다. ECB는 deterministic하므로 동일한 입력은 항상 동일한 출력을 생성합니다. CBC는 이전 블록에 의존하므로 동일한 평문 블록이라도 문맥에 따라 다른 암호문을 생성합니다. 이 차이가 ECB가 보안상 권장되지 않는 주된 이유입니다.",
          "rationale_en": "Incorrect. This is the exact opposite. The student is confusing how the two modes work. ECB is deterministic, so identical inputs always produce identical outputs. CBC depends on the previous block, so identical plaintext blocks produce different ciphertext depending on context. This difference is the main reason ECB is not recommended for security.",
          "isCorrect": false
        },
        {
          "text_ko": "두 모드 모두 서로 다른 암호문을 생성하지만, ECB는 패딩이 필요하고 CBC는 필요하지 않다.",
          "text_en": "Both modes produce different ciphertext, but ECB requires padding while CBC does not.",
          "rationale_ko": "오답입니다. 학생이 두 가지 개념을 혼동하고 있습니다. 첫째, 암호문 생성에 대한 주장이 틀렸습니다—ECB는 동일한 평문에 대해 동일한 암호문을 생성합니다. 둘째, 패딩에 대한 이해가 잘못되었습니다. ECB와 CBC 모두 블록 암호이므로 평문이 블록 크기의 배수가 아닐 경우 패딩이 필요합니다(예: PKCS#7 패딩). 패딩 요구 사항은 암호화 모드가 아니라 블록 암호 자체의 특성입니다.",
          "rationale_en": "Incorrect. The student is confusing two concepts. First, the claim about ciphertext generation is wrong—ECB produces identical ciphertext for identical plaintext. Second, the understanding of padding is incorrect. Both ECB and CBC are block ciphers, so padding is required when plaintext is not a multiple of the block size (e.g., PKCS#7 padding). Padding requirements are a characteristic of block ciphers themselves, not the encryption mode.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "다음 XOR 기반 스트림 암호 구현 코드를 보고 키 재사용 시 발생하는 취약점을 식별하시오:\n\n```python\ndef encrypt(plaintext, key):\n    ciphertext = b''\n    for i in range(len(plaintext)):\n        ciphertext += bytes([plaintext[i] ^ key[i % len(key)]])\n    return ciphertext\n\n# 사용 예\nkey = b'SECRET'\nmsg1 = b'Attack at dawn'\nmsg2 = b'Retreat at dusk'\nc1 = encrypt(msg1, key)\nc2 = encrypt(msg2, key)\n```",
      "question_en": "Given this XOR-based stream cipher implementation, identify the vulnerability when the key is reused:\n\n```python\ndef encrypt(plaintext, key):\n    ciphertext = b''\n    for i in range(len(plaintext)):\n        ciphertext += bytes([plaintext[i] ^ key[i % len(key)]])\n    return ciphertext\n\n# Usage example\nkey = b'SECRET'\nmsg1 = b'Attack at dawn'\nmsg2 = b'Retreat at dusk'\nc1 = encrypt(msg1, key)\nc2 = encrypt(msg2, key)\n```",
      "hint_ko": "두 개의 서로 다른 평문이 동일한 키로 XOR 암호화되었을 때, 두 암호문을 XOR하면 어떤 정보가 남는지 생각해보세요.",
      "hint_en": "Consider what information remains when you XOR two ciphertexts that were encrypted with the same key using XOR encryption.",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Symmetric Encryption - Stream cipher key reuse",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "c1 ⊕ c2 = (p1 ⊕ k) ⊕ (p2 ⊕ k) = p1 ⊕ p2가 되어 키가 제거되므로, 공격자는 두 평문의 XOR 값을 얻게 된다. 평문에 구조가 있거나 알려진 평문 공격이 가능하면 두 메시지를 모두 복구할 수 있다.",
          "text_en": "c1 ⊕ c2 = (p1 ⊕ k) ⊕ (p2 ⊕ k) = p1 ⊕ p2, eliminating the key, so the attacker obtains the XOR of two plaintexts. If the plaintexts have structure or known-plaintext attack is possible, both messages can be recovered.",
          "rationale_ko": "정답입니다. XOR의 성질상 (A ⊕ B) ⊕ (A ⊕ C) = B ⊕ C이므로, 동일한 키로 암호화된 두 암호문을 XOR하면 키가 상쇄되어 두 평문의 XOR만 남습니다. 영어 텍스트의 경우 공백 문자(0x20)가 자주 등장하므로, p1[i] = 0x20이면 (p1 ⊕ p2)[i] = 0x20 ⊕ p2[i]가 되어 p2[i]를 직접 얻을 수 있습니다. 이를 crib-dragging 공격이라 하며, 역사적으로 Venona 프로젝트에서 소련 암호문 해독에 사용되었습니다. 이것이 one-time pad가 정말로 '한 번만' 사용되어야 하는 이유입니다.",
          "rationale_en": "Correct. Due to XOR properties, (A ⊕ B) ⊕ (A ⊕ C) = B ⊕ C, so XORing two ciphertexts encrypted with the same key cancels out the key, leaving only the XOR of two plaintexts. For English text, the space character (0x20) appears frequently, so if p1[i] = 0x20, then (p1 ⊕ p2)[i] = 0x20 ⊕ p2[i], directly revealing p2[i]. This is called a crib-dragging attack and was historically used in the Venona Project to decrypt Soviet messages. This is why a one-time pad must truly be used only 'one time.'",
          "isCorrect": true
        },
        {
          "text_ko": "키가 너무 짧아서(6바이트) 무차별 대입 공격으로 2^48번의 시도만으로 키를 찾을 수 있다.",
          "text_en": "The key is too short (6 bytes), allowing brute force attack to find the key with only 2^48 attempts.",
          "rationale_ko": "오답입니다. 학생이 일반적인 암호학적 약점(짧은 키)을 지적하고 있지만, 이것은 키 재사용과 관련된 특정 취약점이 아닙니다. 2^48은 현대 컴퓨팅으로 실행 가능하지만, 코드에서 더 심각한 문제는 동일한 키스트림을 여러 메시지에 재사용하는 것입니다. 키 길이를 늘려도(예: 32바이트) 키를 재사용하면 동일한 XOR 취약점이 발생합니다. 문제는 키 길이가 아니라 키 재사용 자체입니다.",
          "rationale_en": "Incorrect. The student is pointing out a general cryptographic weakness (short key) but this is not the specific vulnerability related to key reuse. 2^48 is feasible with modern computing, but the more serious issue in the code is reusing the same keystream for multiple messages. Even with a longer key (e.g., 32 bytes), reusing the key causes the same XOR vulnerability. The problem is not key length but key reuse itself.",
          "isCorrect": false
        },
        {
          "text_ko": "키가 평문보다 짧아서 키가 반복되므로(key[i % len(key)]), 패턴 분석으로 키를 추출할 수 있다.",
          "text_en": "The key is shorter than the plaintext, so the key repeats (key[i % len(key)]), allowing pattern analysis to extract the key.",
          "rationale_ko": "오답입니다. 학생이 Vigenère 암호에 대한 빈도 분석을 떠올리고 있는 것 같지만, 단일 암호문에서는 키 반복만으로는 키를 쉽게 추출할 수 없습니다. XOR 암호화는 출력이 균일 분포를 가지므로 빈도 분석이 직접 적용되지 않습니다. 진짜 취약점은 여러 메시지가 동일한 키로 암호화될 때 발생합니다. 예를 들어, msg1[0] ⊕ msg2[0]을 알면 c1[0] ⊕ c2[0]에서 키의 첫 바이트를 제거할 수 있지만, 이것은 키 반복이 아니라 키 재사용 때문입니다.",
          "rationale_en": "Incorrect. The student seems to be thinking of frequency analysis on Vigenère cipher, but key repetition alone cannot easily extract the key from a single ciphertext. XOR encryption has uniformly distributed output, so frequency analysis does not directly apply. The real vulnerability occurs when multiple messages are encrypted with the same key. For example, knowing msg1[0] ⊕ msg2[0] allows removing the first byte of the key from c1[0] ⊕ c2[0], but this is due to key reuse, not key repetition.",
          "isCorrect": false
        },
        {
          "text_ko": "XOR 연산은 가역적이므로 암호문에서 ciphertext[i] ^ key[i % len(key)]를 계산하면 평문을 직접 복구할 수 있다.",
          "text_en": "XOR operation is reversible, so the plaintext can be directly recovered by computing ciphertext[i] ^ key[i % len(key)] from the ciphertext.",
          "rationale_ko": "오답입니다. 학생이 복호화 과정을 설명하고 있지만, 이것은 취약점이 아니라 대칭 암호의 정상적인 작동 방식입니다. 모든 대칭 암호는 키를 알면 복호화가 가능해야 합니다(Kerckhoffs의 원칙). 진짜 취약점은 공격자가 키를 모르는 상태에서도 키 재사용으로 인해 평문 정보를 얻을 수 있다는 것입니다. 이 옵션은 '키를 알면 복호화 가능하다'는 자명한 사실을 취약점으로 착각한 것입니다.",
          "rationale_en": "Incorrect. The student is describing the decryption process, but this is not a vulnerability—it's the normal operation of symmetric encryption. All symmetric ciphers must be decryptable with the key (Kerckhoffs's principle). The real vulnerability is that even without knowing the key, key reuse allows attackers to obtain plaintext information. This option mistakes the trivial fact that 'knowing the key enables decryption' as a vulnerability.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "RSA가 대용량 파일을 직접 암호화하는 데 사용될 수 없는 이유와, 하이브리드 암호화 방식이 이를 어떻게 해결하는가?",
      "question_en": "Why can't RSA be used to directly encrypt large files, and how does hybrid encryption solve this?",
      "hint_ko": "RSA의 수학적 연산 방식과 블록 크기 제약, 그리고 대칭키 암호와 비대칭키 암호의 성능 차이를 고려해보세요.",
      "hint_en": "Consider RSA's mathematical operation method and block size constraints, and the performance difference between symmetric and asymmetric encryption.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Asymmetric Encryption - Hybrid encryption rationale",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "RSA는 모듈러스 크기(예: 2048비트)보다 큰 데이터를 암호화할 수 없고, 연산이 매우 느리다(대칭키 암호 대비 1000배 이상). 하이브리드 암호화는 임의의 대칭키(예: AES 키)로 파일을 암호화하고, 그 대칭키만 RSA 공개키로 암호화하여 전송한다.",
          "text_en": "RSA cannot encrypt data larger than the modulus size (e.g., 2048 bits) and operations are very slow (1000x+ slower than symmetric encryption). Hybrid encryption encrypts the file with a random symmetric key (e.g., AES key) and encrypts only that symmetric key with RSA public key for transmission.",
          "rationale_ko": "정답입니다. RSA 암호화는 m^e mod n 연산을 수행하므로 m < n이어야 합니다. 2048비트 RSA는 최대 256바이트만 암호화할 수 있으며, 패딩(OAEP)을 고려하면 실제로는 214바이트 미만입니다. 또한 modular exponentiation은 연산 집약적이어서 AES보다 수천 배 느립니다. 하이브리드 방식(예: TLS)은 이 문제를 해결합니다: (1) 송신자가 임의 AES-256 키 생성, (2) AES로 대용량 데이터 암호화, (3) AES 키를 수신자 RSA 공개키로 암호화, (4) 암호화된 AES 키와 암호화된 데이터를 함께 전송. 수신자는 RSA 개인키로 AES 키를 복호화한 후 데이터를 복호화합니다.",
          "rationale_en": "Correct. RSA encryption performs m^e mod n operation, requiring m < n. 2048-bit RSA can encrypt maximum 256 bytes, and with padding (OAEP) consideration, actually less than 214 bytes. Additionally, modular exponentiation is computationally intensive, thousands of times slower than AES. Hybrid approach (e.g., TLS) solves this: (1) sender generates random AES-256 key, (2) encrypts large data with AES, (3) encrypts AES key with recipient's RSA public key, (4) transmits encrypted AES key and encrypted data together. Recipient decrypts AES key with RSA private key, then decrypts data.",
          "isCorrect": true
        },
        {
          "text_ko": "RSA는 공개키 암호이므로 기밀성을 제공하지 않으며, 하이브리드 방식은 RSA를 서명에만 사용하고 실제 암호화는 AES로 수행한다.",
          "text_en": "RSA is public key cryptography so it doesn't provide confidentiality, and hybrid approach uses RSA only for signatures while actual encryption is done with AES.",
          "rationale_ko": "오답입니다. 학생이 공개키 암호의 작동 방식을 근본적으로 오해하고 있습니다. RSA는 공개키로 암호화하고 개인키로 복호화하므로 기밀성을 제공합니다(공개키는 공개되어 있지만 개인키만이 복호화 가능). 디지털 서명은 반대로 개인키로 서명하고 공개키로 검증합니다. 하이브리드 암호화에서 RSA는 서명이 아니라 대칭키 암호화에 사용됩니다. 이 혼동은 '공개키'라는 용어가 보안을 약화시킨다는 잘못된 직관에서 비롯될 수 있습니다.",
          "rationale_en": "Incorrect. The student fundamentally misunderstands how public key cryptography works. RSA provides confidentiality by encrypting with public key and decrypting with private key (public key is public but only private key can decrypt). Digital signatures work oppositely: sign with private key and verify with public key. In hybrid encryption, RSA is used for symmetric key encryption, not signing. This confusion may stem from the false intuition that the term 'public key' weakens security.",
          "isCorrect": false
        },
        {
          "text_ko": "RSA는 결정론적(deterministic) 암호이므로 동일한 파일은 항상 동일한 암호문을 생성하여 보안이 약하다. 하이브리드 방식은 매번 다른 난수를 추가하여 이를 해결한다.",
          "text_en": "RSA is deterministic encryption, so identical files always produce identical ciphertext, weakening security. Hybrid approach adds different random numbers each time to solve this.",
          "rationale_ko": "오답입니다. 학생이 여러 개념을 혼동하고 있습니다. 첫째, 표준 RSA(교과서 RSA)는 결정론적이지만, 실제로는 OAEP 같은 패딩을 사용하여 확률적(probabilistic)으로 만듭니다. 둘째, 결정론성이 RSA가 대용량 파일에 사용되지 못하는 주된 이유가 아닙니다—크기 제약과 성능이 더 중요합니다. 셋째, 하이브리드 암호화의 주 목적은 난수 추가가 아니라 성능과 크기 제약 해결입니다. 대칭키 자체가 매번 랜덤하게 생성되므로 의미론적 보안이 제공되지만, 이것은 부차적 이점입니다.",
          "rationale_en": "Incorrect. The student is confusing several concepts. First, standard RSA (textbook RSA) is deterministic, but in practice, padding like OAEP is used to make it probabilistic. Second, determinism is not the main reason RSA can't be used for large files—size constraints and performance are more critical. Third, the main purpose of hybrid encryption is not adding random numbers but solving performance and size constraints. Since the symmetric key itself is randomly generated each time, semantic security is provided, but this is a secondary benefit.",
          "isCorrect": false
        },
        {
          "text_ko": "RSA는 블록 암호가 아니라 스트림 암호이므로 파일을 블록 단위로 나눌 수 없다. 하이브리드 방식은 AES 같은 블록 암호를 사용하여 파일을 블록으로 나누어 처리한다.",
          "text_en": "RSA is a stream cipher not a block cipher, so files cannot be divided into blocks. Hybrid approach uses block ciphers like AES to divide files into blocks for processing.",
          "rationale_ko": "오답입니다. 학생이 암호 유형 분류를 완전히 잘못 이해하고 있습니다. RSA는 블록 암호도 스트림 암호도 아니며, 공개키(비대칭) 암호 시스템입니다. 블록 암호(AES, DES)와 스트림 암호(RC4, ChaCha20)는 모두 대칭키 암호의 하위 분류입니다. RSA는 수학적으로 정수론(modular exponentiation)에 기반하며, 한 번에 하나의 '블록'(모듈러스 크기 미만)만 암호화할 수 있지만 이것이 블록 암호를 의미하지 않습니다. 이 오답은 근본적인 분류 오류를 보여줍니다.",
          "rationale_en": "Incorrect. The student completely misunderstands cipher type classification. RSA is neither a block cipher nor a stream cipher but a public key (asymmetric) cryptosystem. Block ciphers (AES, DES) and stream ciphers (RC4, ChaCha20) are both subcategories of symmetric key cryptography. RSA is mathematically based on number theory (modular exponentiation) and can encrypt only one 'block' (less than modulus size) at a time, but this doesn't mean it's a block cipher. This wrong answer demonstrates fundamental classification error.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "RSA 키 생성 과정에서 p=5, q=11, e=3일 때, d를 계산하고 gcd(e, φ(n))=1이 왜 필요한지 설명하시오.",
      "question_en": "In RSA key generation, if p=5, q=11, e=3, compute d and explain why gcd(e, φ(n))=1 is required.",
      "hint_ko": "오일러 파이 함수의 값과 모듈러 역원의 존재 조건을 생각해보세요.",
      "hint_en": "Consider the value of Euler's phi function and the condition for the existence of modular inverse.",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Asymmetric Encryption - RSA key generation mathematics",
      "questionType": "code_trace",
      "answerOptions": [
        {
          "text_ko": "n=55, φ(n)=(5-1)(11-1)=40이므로, e·d≡1 (mod 40)을 만족하는 d를 찾으면 d=27이다. gcd(e,φ(n))=1이어야 하는 이유는 e가 φ(n)과 서로소여야만 모듈러 역원 d가 유일하게 존재하기 때문이다. 그렇지 않으면 복호화가 불가능하다.",
          "text_en": "n=55, φ(n)=(5-1)(11-1)=40, so finding d that satisfies e·d≡1 (mod 40) gives d=27. gcd(e,φ(n))=1 is required because e must be coprime with φ(n) for the modular inverse d to exist uniquely. Otherwise, decryption is impossible.",
          "rationale_ko": "정답입니다. 확장 유클리드 알고리즘으로 계산하면: 40 = 13·3 + 1, 3 = 3·1 + 0이므로 1 = 40 - 13·3, 즉 3·(-13) ≡ 1 (mod 40). d는 양수여야 하므로 d = -13 + 40 = 27입니다. 검증: 3·27 = 81 = 2·40 + 1 ≡ 1 (mod 40). gcd(e, φ(n))=1 조건이 필수인 이유는 Bézout의 정리에 의해 ax + by = gcd(a,b)의 정수 해가 존재하며, gcd(e, φ(n))=1일 때만 e·d ≡ 1 (mod φ(n))의 해가 존재하기 때문입니다. 만약 gcd(e, φ(n))=g>1이면, e·d는 g의 배수만 생성하므로 1 (mod φ(n))이 될 수 없습니다. 이는 오일러 정리 (m^φ(n) ≡ 1 (mod n))를 활용한 RSA의 정확성 증명에 필수적입니다.",
          "rationale_en": "Correct. Using the Extended Euclidean Algorithm: 40 = 13·3 + 1, 3 = 3·1 + 0, so 1 = 40 - 13·3, meaning 3·(-13) ≡ 1 (mod 40). Since d must be positive, d = -13 + 40 = 27. Verification: 3·27 = 81 = 2·40 + 1 ≡ 1 (mod 40). The gcd(e, φ(n))=1 condition is essential because Bézout's identity states that integer solutions to ax + by = gcd(a,b) exist, and only when gcd(e, φ(n))=1 does a solution to e·d ≡ 1 (mod φ(n)) exist. If gcd(e, φ(n))=g>1, then e·d can only generate multiples of g and cannot equal 1 (mod φ(n)). This is essential for proving RSA correctness using Euler's theorem (m^φ(n) ≡ 1 (mod n)).",
          "isCorrect": true
        },
        {
          "text_ko": "n=55, φ(n)=55이므로 d=18이다. gcd(e,φ(n))=1 조건은 소인수분해 공격을 방지하기 위한 것이다.",
          "text_en": "n=55, φ(n)=55, so d=18. The gcd(e,φ(n))=1 condition is to prevent factorization attacks.",
          "rationale_ko": "오답입니다. 학생이 두 가지 오류를 범했습니다. 첫째, φ(n) 계산이 틀렸습니다. φ(n)은 n 자체가 아니라 (p-1)(q-1) = 40입니다. 둘째, gcd 조건의 목적을 오해했습니다. 이 조건은 소인수분해 공격 방지가 아니라(p, q의 크기와 선택이 이를 담당) 모듈러 역원의 수학적 존재성을 보장하기 위한 것입니다. d=18로 검증하면 3·18=54≢1 (mod 40)이므로 올바른 복호화 키가 아닙니다.",
          "rationale_en": "Incorrect. The student made two errors. First, φ(n) calculation is wrong. φ(n) is (p-1)(q-1) = 40, not n itself. Second, misunderstood the purpose of the gcd condition. This condition is not for preventing factorization attacks (which is addressed by the size and selection of p, q) but for ensuring the mathematical existence of the modular inverse. Verifying with d=18: 3·18=54≢1 (mod 40), so it's not the correct decryption key.",
          "isCorrect": false
        },
        {
          "text_ko": "φ(n)=p·q=55이므로 e·d≡1 (mod 55)를 풀면 d=37이다. gcd 조건은 e가 소수여야 한다는 의미이다.",
          "text_en": "φ(n)=p·q=55, so solving e·d≡1 (mod 55) gives d=37. The gcd condition means e must be prime.",
          "rationale_ko": "오답입니다. 첫째, φ(n) = p·q가 아니라 φ(n) = (p-1)(q-1)입니다. 학생이 오일러 파이 함수의 정의를 n의 계산과 혼동했습니다. 둘째, gcd(e, φ(n))=1은 'e가 소수'를 의미하지 않습니다. 서로소(coprime)는 공약수가 1뿐임을 의미하며, e는 소수가 아니어도 됩니다(예: e=65537=2^16+1은 소수이지만, e=9도 φ(n)=40과 서로소가 아니므로 사용 불가). 실제로 흔히 사용되는 e=65537은 소수이지만, e=3, 5, 17 등 작은 소수도 사용됩니다. 중요한 것은 소수 여부가 아니라 φ(n)과의 최대공약수가 1인지입니다.",
          "rationale_en": "Incorrect. First, φ(n) ≠ p·q but φ(n) = (p-1)(q-1). The student confused the Euler's phi function definition with the calculation of n. Second, gcd(e, φ(n))=1 does not mean 'e must be prime.' Coprime means having only 1 as a common divisor, and e doesn't need to be prime (e.g., e=65537=2^16+1 is prime, but e=9 also cannot be used as it's not coprime with φ(n)=40). In practice, commonly used e=65537 is prime, but small primes like e=3, 5, 17 are also used. What matters is not whether it's prime but whether the greatest common divisor with φ(n) is 1.",
          "isCorrect": false
        },
        {
          "text_ko": "d = φ(n) - e = 40 - 3 = 37이다. gcd 조건이 없으면 암호화와 복호화에 같은 키를 사용하게 되어 대칭키 암호가 되기 때문이다.",
          "text_en": "d = φ(n) - e = 40 - 3 = 37. Without the gcd condition, encryption and decryption would use the same key, becoming symmetric encryption.",
          "rationale_ko": "오답입니다. 학생이 d 계산 방법을 완전히 오해했습니다. d는 단순 뺄셈이 아니라 모듈러 역원입니다. 검증: 3·37 = 111 = 2·40 + 31 ≡ 31 (mod 40) ≠ 1이므로 틀렸습니다. gcd 조건의 설명도 틀렸습니다. RSA는 항상 비대칭 암호이며(e와 d가 다름), gcd 조건이 없으면 대칭 암호가 되는 것이 아니라 수학적으로 복호화가 불가능합니다. 공개키 e와 개인키 d는 수학적 관계(e·d ≡ 1 mod φ(n))로 연결되어 있지만 서로 다른 값이며, 이 관계가 성립하려면 e와 φ(n)이 서로소여야 합니다.",
          "rationale_en": "Incorrect. The student completely misunderstands d calculation. d is not simple subtraction but modular inverse. Verification: 3·37 = 111 = 2·40 + 31 ≡ 31 (mod 40) ≠ 1, so it's wrong. The gcd condition explanation is also incorrect. RSA is always asymmetric encryption (e and d are different), and without the gcd condition, it doesn't become symmetric encryption but decryption becomes mathematically impossible. Public key e and private key d are connected by mathematical relationship (e·d ≡ 1 mod φ(n)) but are different values, and for this relationship to hold, e and φ(n) must be coprime.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "RSA-2048과 ECC-256을 비교할 때, ECC가 더 작은 키 크기로 동등한 보안을 제공하는 이유는 무엇인가?",
      "question_en": "When comparing RSA-2048 vs ECC-256, why does ECC provide equivalent security with a smaller key size?",
      "hint_ko": "각 암호 시스템의 기반이 되는 수학적 난제와 그것을 푸는 알고리즘의 복잡도를 비교해보세요.",
      "hint_en": "Compare the mathematical hard problems underlying each cryptosystem and the complexity of algorithms that solve them.",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Asymmetric Encryption - RSA vs ECC security comparison",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "RSA는 정수 소인수분해 문제에 의존하며 가장 빠른 공격인 General Number Field Sieve (GNFS)가 준지수(subexponential) 시간이다. ECC는 타원곡선 이산대수 문제(ECDLP)에 의존하며 최선의 알고리즘인 Pollard's rho가 지수(exponential) 시간이다. 따라서 ECC-256은 RSA-2048과 비슷한 112-128비트 보안 강도를 제공한다.",
          "text_en": "RSA relies on integer factorization problem, with the fastest attack being General Number Field Sieve (GNFS) at subexponential time. ECC relies on Elliptic Curve Discrete Logarithm Problem (ECDLP), with the best algorithm being Pollard's rho at exponential time. Thus, ECC-256 provides similar 112-128 bit security strength as RSA-2048.",
          "rationale_ko": "정답입니다. 암호 시스템의 보안은 기반 수학 문제를 푸는 복잡도로 결정됩니다. GNFS는 O(exp((64/9)^(1/3) * (log n)^(1/3) * (log log n)^(2/3))) 복잡도를 가지므로 RSA-2048은 약 112비트 보안 강도를 제공합니다. 반면 ECDLP에 대한 Pollard's rho는 O(√n) = O(2^(k/2))로 지수 복잡도이므로 ECC-256은 128비트 보안 강도를 제공합니다. NIST 권고에 따르면 112비트 보안을 위해 RSA는 2048비트, ECC는 224비트가 필요하며, 128비트 보안을 위해서는 RSA 3072비트, ECC 256비트가 필요합니다. 이 차이로 인해 ECC는 더 작은 키, 빠른 연산, 적은 대역폭으로 동등한 보안을 제공하여 모바일과 IoT 환경에서 선호됩니다.",
          "rationale_en": "Correct. Cryptosystem security is determined by the complexity of solving the underlying mathematical problem. GNFS has complexity O(exp((64/9)^(1/3) * (log n)^(1/3) * (log log n)^(2/3))), so RSA-2048 provides approximately 112-bit security strength. Meanwhile, Pollard's rho for ECDLP has exponential complexity O(√n) = O(2^(k/2)), so ECC-256 provides 128-bit security strength. According to NIST recommendations, for 112-bit security, RSA requires 2048 bits while ECC requires 224 bits, and for 128-bit security, RSA requires 3072 bits while ECC requires 256 bits. This difference allows ECC to provide equivalent security with smaller keys, faster operations, and less bandwidth, making it preferred in mobile and IoT environments.",
          "isCorrect": true
        },
        {
          "text_ko": "ECC는 타원곡선의 점들을 사용하므로 2차원 공간에서 작동하지만, RSA는 1차원 정수를 사용하므로 더 큰 키가 필요하다.",
          "text_en": "ECC uses points on elliptic curves working in 2D space, but RSA uses 1D integers, requiring larger keys.",
          "rationale_ko": "오답입니다. 학생이 수학적 차원을 물리적 효율성과 잘못 연관 짓고 있습니다. 타원곡선의 점이 (x, y) 좌표를 가진다고 해서 '2차원'이 보안 이점을 주는 것이 아닙니다. 보안 강도는 기반 수학 문제의 계산 복잡도에서 나옵니다. 실제로 타원곡선 점은 유한체 상에서 정의되며, 점 덧셈은 복잡한 대수적 연산입니다. RSA의 정수도 매우 큰 유한체(Z_n)에서 작동합니다. 차원성은 키 크기와 직접적인 관련이 없습니다.",
          "rationale_en": "Incorrect. The student is wrongly associating mathematical dimensions with physical efficiency. Just because elliptic curve points have (x, y) coordinates doesn't mean '2D' provides security advantage. Security strength comes from the computational complexity of the underlying mathematical problem. In fact, elliptic curve points are defined over finite fields, and point addition is a complex algebraic operation. RSA integers also operate in a very large finite field (Z_n). Dimensionality has no direct relation to key size.",
          "isCorrect": false
        },
        {
          "text_ko": "ECC-256은 256비트 블록을 한 번에 암호화하지만 RSA-2048은 2048비트를 여러 번에 나누어 처리하므로 비효율적이다.",
          "text_en": "ECC-256 encrypts 256-bit blocks at once while RSA-2048 divides 2048 bits into multiple operations, making it inefficient.",
          "rationale_ko": "오답입니다. 학생이 키 크기를 블록 크기 또는 처리 단위와 혼동하고 있습니다. RSA-2048은 2048비트 키를 사용하지만, 한 번에 암호화할 수 있는 데이터는 키보다 작습니다(패딩 때문에 약 214바이트). ECC-256도 256비트 블록을 암호화하는 것이 아니라, 256비트 곡선 매개변수를 사용하여 키 교환이나 서명을 수행합니다. 실제로 ECC는 대용량 데이터 암호화에 직접 사용되지 않고 ECIES 같은 하이브리드 방식을 사용합니다. 키 크기 효율성은 블록 처리 방식이 아니라 기반 수학 문제의 복잡도 차이에서 비롯됩니다.",
          "rationale_en": "Incorrect. The student is confusing key size with block size or processing units. RSA-2048 uses a 2048-bit key but can encrypt data smaller than the key at once (approximately 214 bytes due to padding). ECC-256 doesn't encrypt 256-bit blocks either; it uses 256-bit curve parameters to perform key exchange or signatures. In fact, ECC is not directly used for bulk data encryption but employs hybrid approaches like ECIES. Key size efficiency comes from the difference in complexity of underlying mathematical problems, not block processing methods.",
          "isCorrect": false
        },
        {
          "text_ko": "RSA는 양자 컴퓨터에 취약하지만 ECC는 양자 저항성이 있으므로 더 작은 키로도 안전하다.",
          "text_en": "RSA is vulnerable to quantum computers but ECC has quantum resistance, so it's safe with smaller keys.",
          "rationale_ko": "오답입니다. 이것은 사실이 아닙니다. Shor의 알고리즘은 정수 소인수분해와 이산대수 문제 모두를 다항 시간에 풀 수 있으므로, 충분히 큰 양자 컴퓨터가 등장하면 RSA와 ECC 모두 안전하지 않습니다. 양자 저항성(post-quantum cryptography)을 위해서는 격자 기반 암호(lattice-based), 코드 기반 암호, 해시 기반 서명 등 완전히 다른 수학적 기반이 필요합니다. 현재 ECC가 더 작은 키로 안전한 이유는 양자 저항성 때문이 아니라 고전 컴퓨터에서의 ECDLP 복잡도 때문입니다.",
          "rationale_en": "Incorrect. This is factually wrong. Shor's algorithm can solve both integer factorization and discrete logarithm problems in polynomial time, so when sufficiently large quantum computers emerge, both RSA and ECC will be insecure. For quantum resistance (post-quantum cryptography), completely different mathematical foundations are needed, such as lattice-based, code-based, or hash-based signatures. The reason ECC is currently safe with smaller keys is not quantum resistance but ECDLP complexity on classical computers.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "공개키 e와 모듈러스 n을 알고 있을 때, 개인키 d 없이 복호화할 수 없는 이유를 계산 복잡도 관점에서 설명하시오.",
      "question_en": "Explain why you cannot decrypt without the private key d when you know the public key e and modulus n, from a computational complexity perspective.",
      "hint_ko": "RSA의 안전성이 의존하는 수학적 난제와, 그 문제를 푸는 데 필요한 시간을 생각해보세요.",
      "hint_en": "Consider the mathematical hard problem RSA security relies on and the time required to solve that problem.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Asymmetric Encryption - RSA computational hardness assumption",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "d를 계산하려면 φ(n)=(p-1)(q-1)을 알아야 하고, 이를 위해서는 n=p·q를 소인수분해해야 한다. 충분히 큰 n(예: 2048비트)의 소인수분해는 현재 알려진 최선의 알고리즘(GNFS)으로도 수십억 년이 걸려 계산적으로 불가능하다.",
          "text_en": "To compute d, you need φ(n)=(p-1)(q-1), which requires factoring n=p·q. Factoring sufficiently large n (e.g., 2048 bits) takes billions of years even with the best known algorithm (GNFS), making it computationally infeasible.",
          "rationale_ko": "정답입니다. RSA 보안의 핵심은 정수 소인수분해 문제의 어려움입니다. 공개키 (e, n)으로부터 개인키 d를 계산하는 과정: (1) n을 소인수 p, q로 분해, (2) φ(n) = (p-1)(q-1) 계산, (3) e·d ≡ 1 (mod φ(n))을 만족하는 d 계산. 3단계는 확장 유클리드 알고리즘으로 다항 시간에 가능하지만, 1단계가 문제입니다. 2048비트 n의 소인수분해는 GNFS로도 O(exp(1.9(log n)^(1/3)(log log n)^(2/3))) 복잡도를 가지며, 현실적으로 불가능합니다. 예를 들어 RSA-768(232자리 십진수) 소인수분해에 수백 코어-년이 소요되었으며, RSA-2048은 현재 기술로 수십억 배 더 어렵습니다. 이것이 RSA의 계산 복잡도 기반 안전성입니다.",
          "rationale_en": "Correct. The core of RSA security is the difficulty of the integer factorization problem. Process to compute private key d from public key (e, n): (1) factor n into prime factors p, q, (2) compute φ(n) = (p-1)(q-1), (3) compute d satisfying e·d ≡ 1 (mod φ(n)). Step 3 is polynomial time with Extended Euclidean Algorithm, but step 1 is the problem. Factoring 2048-bit n has complexity O(exp(1.9(log n)^(1/3)(log log n)^(2/3))) even with GNFS, making it practically infeasible. For example, factoring RSA-768 (232 decimal digits) took hundreds of core-years, and RSA-2048 is billions of times harder with current technology. This is RSA's computational complexity-based security.",
          "isCorrect": true
        },
        {
          "text_ko": "n과 e를 알아도 d를 계산할 수 없는 이유는 RSA 알고리즘이 일방향 함수(one-way function)를 사용하기 때문이며, 수학적으로 역함수가 존재하지 않는다.",
          "text_en": "You cannot compute d from knowing n and e because RSA uses a one-way function, and mathematically the inverse function does not exist.",
          "rationale_ko": "오답입니다. 학생이 '계산 복잡도'와 '수학적 불가능성'을 혼동하고 있습니다. 일방향 함수는 계산하기 쉽지만 역계산이 '계산적으로 어려운' 함수이지, 수학적으로 역함수가 존재하지 않는 것이 아닙니다. 실제로 d는 수학적으로 정확히 정의되어 있으며(e·d ≡ 1 mod φ(n)의 유일해), p와 q를 알면 쉽게 계산할 수 있습니다. 문제는 p와 q를 '찾는 것'이 계산적으로 어렵다는 것입니다. 이것은 P≠NP 추측과 관련된 계산 복잡도 이론의 문제이지, 수학적 존재성의 문제가 아닙니다.",
          "rationale_en": "Incorrect. The student is confusing 'computational complexity' with 'mathematical impossibility.' A one-way function is easy to compute but 'computationally hard' to invert, not mathematically lacking an inverse function. In fact, d is mathematically precisely defined (unique solution to e·d ≡ 1 mod φ(n)) and easily computed if p and q are known. The problem is that 'finding' p and q is computationally hard. This is a computational complexity theory issue related to the P≠NP conjecture, not a mathematical existence problem.",
          "isCorrect": false
        },
        {
          "text_ko": "e와 n만으로는 암호문 c에서 평문 m을 얻을 수 없는데, 이는 m^e mod n 연산이 비가역적이기 때문이다.",
          "text_en": "With only e and n, you cannot obtain plaintext m from ciphertext c because the operation m^e mod n is irreversible.",
          "rationale_ko": "오답입니다. 학생이 '비가역적'이라는 용어를 잘못 사용하고 있습니다. m^e mod n 연산은 수학적으로 가역적입니다—그것이 바로 복호화 과정 c^d mod n = m입니다. 문제는 개인키 d를 모르는 상태에서 c^d를 계산할 수 없다는 것입니다. 이론적으로는 e제곱근을 mod n에서 구하면 되지만, 이것이 바로 RSA 문제로 알려진 난제입니다. 이것은 연산의 비가역성이 아니라 역원(d)을 찾는 것의 계산적 어려움입니다. 또한 이 설명은 '왜 d 없이 복호화할 수 없는가'가 아니라 '왜 복호화가 가능한가'를 설명하고 있어 질문을 벗어났습니다.",
          "rationale_en": "Incorrect. The student is misusing the term 'irreversible.' The operation m^e mod n is mathematically reversible—that's exactly the decryption process c^d mod n = m. The problem is that without knowing the private key d, you cannot compute c^d. Theoretically, you could find the eth root mod n, but this is exactly the hard problem known as the RSA problem. This is not irreversibility of the operation but computational difficulty of finding the inverse (d). Also, this explanation describes 'why decryption is possible' rather than 'why decryption is impossible without d,' missing the question.",
          "isCorrect": false
        },
        {
          "text_ko": "실제로는 e, n을 알면 무차별 대입 공격으로 d를 찾을 수 있지만, d의 크기가 n과 비슷하므로(약 2048비트) 2^2048번의 시도가 필요해 현실적으로 불가능하다.",
          "text_en": "In reality, knowing e and n allows finding d through brute force attack, but since d is similar in size to n (about 2048 bits), it requires 2^2048 attempts, making it practically impossible.",
          "rationale_ko": "오답입니다. 학생이 공격 방법을 오해하고 있습니다. d를 직접 무차별 대입으로 찾는 것은 비효율적입니다. 더 나은 공격 방법은 n을 소인수분해하여 p, q를 찾은 후 φ(n)을 계산하고 d를 도출하는 것입니다. 소인수분해의 복잡도는 2^2048보다 훨씬 낮지만(GNFS는 준지수 시간), 여전히 현실적으로 불가능합니다. 또한 d의 크기는 반드시 2048비트가 아닙니다—d < φ(n) < n이지만 비트 길이는 다를 수 있습니다. 이 답변은 공격 벡터를 잘못 식별했고 복잡도 분석도 부정확합니다.",
          "rationale_en": "Incorrect. The student misunderstands the attack method. Direct brute force search for d is inefficient. A better attack method is to factor n to find p, q, then compute φ(n) and derive d. Factorization complexity is much lower than 2^2048 (GNFS is subexponential time), though still practically infeasible. Also, d's size is not necessarily 2048 bits—while d < φ(n) < n, bit length can differ. This answer incorrectly identifies the attack vector and has inaccurate complexity analysis.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "MD5가 디지털 서명에는 더 이상 안전하지 않지만, 파일 무결성 체크섬에는 여전히 허용되는 이유는 무엇인가?",
      "question_en": "Why is MD5 no longer considered secure for digital signatures, but still acceptable for checksums?",
      "hint_ko": "충돌 공격(collision attack)의 의미와, 서명 검증과 단순 무결성 확인에서 공격자가 가진 통제력의 차이를 생각해보세요.",
      "hint_en": "Consider the meaning of collision attacks and the difference in attacker control between signature verification and simple integrity checking.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Cryptographic Hash Functions - MD5 security context",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "디지털 서명에서는 공격자가 두 개의 다른 문서를 만들어 동일한 해시를 생성할 수 있고(충돌 공격), 한 문서에 대한 서명을 다른 악의적 문서에 재사용할 수 있다. 체크섬에서는 원본 파일이 먼저 존재하므로 공격자가 동일한 해시를 가진 악의적 파일을 만들어야 하는데(제2 원상 공격), 이는 MD5에서 아직 실용적이지 않다.",
          "text_en": "In digital signatures, an attacker can create two different documents with identical hashes (collision attack) and reuse the signature from one document for a malicious document. For checksums, the original file exists first, so the attacker must create a malicious file with the same hash (second preimage attack), which is not yet practical for MD5.",
          "rationale_ko": "정답입니다. MD5의 충돌 공격은 2004년 Wang et al.에 의해 입증되었으며, 2^20 연산으로 가능합니다(이론적 2^64보다 훨씬 낮음). 디지털 서명 시나리오: 공격자가 무해한 문서 D1과 악의적 문서 D2를 만들어 MD5(D1) = MD5(D2)가 되도록 합니다. 피해자가 D1에 서명하면, 공격자는 그 서명을 D2에도 사용할 수 있습니다(서명은 해시 값에 대해 수행되므로). 이것이 MD5가 서명에 부적합한 이유입니다. 반면 체크섬 시나리오: 원본 파일 F가 먼저 존재하고 MD5(F)가 게시됩니다. 공격자는 MD5(F') = MD5(F)를 만족하는 악의적 F'를 찾아야 하는데, 이는 제2 원상 공격으로 여전히 2^128 복잡도를 가져 현실적으로 불가능합니다. 따라서 단순 무결성 검증(의도하지 않은 손상 탐지)에는 MD5가 여전히 사용 가능하지만, 적대적 시나리오에서는 SHA-256 이상을 사용해야 합니다.",
          "rationale_en": "Correct. MD5 collision attack was demonstrated by Wang et al. in 2004 with 2^20 operations (much lower than theoretical 2^64). Digital signature scenario: attacker creates benign document D1 and malicious document D2 such that MD5(D1) = MD5(D2). When victim signs D1, attacker can use that signature for D2 (since signature is performed on hash value). This is why MD5 is unsuitable for signatures. Checksum scenario: original file F exists first and MD5(F) is published. Attacker must find malicious F' satisfying MD5(F') = MD5(F), which is a second preimage attack still having 2^128 complexity, making it practically infeasible. Therefore, MD5 is still usable for simple integrity verification (detecting unintentional corruption), but SHA-256 or higher should be used in adversarial scenarios.",
          "isCorrect": true
        },
        {
          "text_ko": "디지털 서명은 기밀성이 필요하지만 체크섬은 기밀성이 필요 없으므로, MD5의 충돌 취약점이 체크섬에는 영향을 미치지 않는다.",
          "text_en": "Digital signatures require confidentiality while checksums don't, so MD5's collision vulnerability doesn't affect checksums.",
          "rationale_ko": "오답입니다. 학생이 디지털 서명의 목적을 오해하고 있습니다. 디지털 서명은 기밀성(confidentiality)이 아니라 인증(authentication), 무결성(integrity), 부인방지(non-repudiation)를 제공합니다. 기밀성은 암호화의 목표입니다. MD5의 충돌 취약점은 기밀성과 무관하며, 무결성 보장 능력의 문제입니다. 체크섬도 무결성을 확인하므로 이 구분은 잘못되었습니다. 진짜 차이는 공격 모델(collision vs second preimage)과 공격자의 통제 범위입니다.",
          "rationale_en": "Incorrect. The student misunderstands the purpose of digital signatures. Digital signatures provide authentication, integrity, and non-repudiation, not confidentiality. Confidentiality is the goal of encryption. MD5's collision vulnerability is unrelated to confidentiality and is a problem of integrity assurance capability. Checksums also verify integrity, so this distinction is wrong. The real difference is the attack model (collision vs second preimage) and the scope of attacker control.",
          "isCorrect": false
        },
        {
          "text_ko": "MD5는 128비트 출력을 생성하는데, 이것이 디지털 서명에는 너무 짧지만 체크섬에는 충분하다.",
          "text_en": "MD5 produces 128-bit output, which is too short for digital signatures but sufficient for checksums.",
          "rationale_ko": "오답입니다. 학생이 출력 길이를 보안 문제로 잘못 연관 짓고 있습니다. 128비트는 실제로 충돌 공격에 대해서는 이론적으로 2^64 보안 강도를 제공해야 하는데(생일 공격), 이는 현재 기준으로도 적절합니다. 문제는 출력 길이가 아니라 MD5의 구조적 취약점으로 인해 충돌을 2^20 연산으로 찾을 수 있다는 것입니다. SHA-256(256비트)도 출력이 길어서가 아니라 충돌 공격이 발견되지 않았기 때문에 안전합니다. 또한 디지털 서명 알고리즘(RSA, ECDSA)은 다양한 해시 길이를 지원하므로 128비트가 '너무 짧다'는 절대적 기준은 없습니다.",
          "rationale_en": "Incorrect. The student is wrongly associating output length with security issues. 128 bits should theoretically provide 2^64 security strength against collision attacks (birthday attack), which is adequate even by current standards. The problem is not output length but MD5's structural weakness allowing collisions to be found with 2^20 operations. SHA-256 (256 bits) is secure not because of longer output but because no collision attack has been found. Also, digital signature algorithms (RSA, ECDSA) support various hash lengths, so there's no absolute standard that 128 bits is 'too short.'",
          "isCorrect": false
        },
        {
          "text_ko": "디지털 서명은 공개키 암호를 사용하므로 해시 함수의 보안이 중요하지만, 체크섬은 대칭키 방식이므로 MD5로도 충분하다.",
          "text_en": "Digital signatures use public key cryptography so hash function security is important, but checksums use symmetric key methods so MD5 is sufficient.",
          "rationale_ko": "오답입니다. 학생이 체크섬과 대칭키 암호를 혼동하고 있습니다. 체크섬(checksum)은 암호화가 아니며 키를 사용하지 않습니다—단순히 데이터의 해시 값을 계산하여 나중에 비교하는 것입니다. HMAC는 키를 사용하는 해시 기반 메시지 인증 코드이지만, 이것도 체크섬과는 다릅니다. 디지털 서명에서 해시 함수가 중요한 이유는 공개키 암호 사용 때문이 아니라, 서명 과정에서 충돌 공격이 직접적인 위협이 되기 때문입니다. 체크섬에서도 해시 함수는 중요하지만, 공격 모델이 다를 뿐입니다.",
          "rationale_en": "Incorrect. The student is confusing checksums with symmetric key cryptography. Checksums are not encryption and don't use keys—they simply compute a hash value of data for later comparison. HMAC is a keyed hash-based message authentication code, but this is also different from checksums. Hash functions are important in digital signatures not because of public key cryptography use but because collision attacks are a direct threat in the signing process. Hash functions are also important for checksums, but the attack model is different.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "256비트 해시 함수에서 충돌을 찾는 데 2^128번의 연산만 필요한 이유를 생일 역설(birthday paradox)로 설명하시오.",
      "question_en": "Explain using the birthday paradox why finding a collision in a 256-bit hash function requires only 2^128 operations.",
      "hint_ko": "n개의 가능한 값이 있을 때, 두 개의 값이 일치할 확률이 50%가 되려면 몇 개의 샘플이 필요한지 생각해보세요.",
      "hint_en": "Consider how many samples are needed for a 50% probability that two values match when there are n possible values.",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Cryptographic Hash Functions - Birthday attack complexity",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "생일 역설에 따르면, n개의 가능한 값에서 충돌이 발생할 확률이 50%가 되려면 약 √n개의 샘플이 필요하다. 256비트 해시는 2^256개의 가능한 값을 가지므로, √(2^256) = 2^128개의 해시를 계산하면 충돌을 발견할 가능성이 높다. 이는 전수 조사 2^256보다 2^128배 효율적이다.",
          "text_en": "According to the birthday paradox, approximately √n samples are needed for a 50% probability of collision among n possible values. A 256-bit hash has 2^256 possible values, so computing √(2^256) = 2^128 hashes gives a high chance of finding a collision. This is 2^128 times more efficient than exhaustive search of 2^256.",
          "rationale_ko": "정답입니다. 생일 역설의 핵심: 23명의 사람이 있을 때 두 명이 같은 생일을 가질 확률이 50%를 초과합니다(365일 중). 이는 직관에 반하지만 √365 ≈ 19.1로 설명됩니다. 수학적으로, n개의 가능한 해시 값에 대해 충돌 확률 P는 P ≈ 1 - e^(-k^2/2n)로 근사되며, P=0.5일 때 k ≈ 1.17√n입니다. 256비트 해시에서 n=2^256이므로 k ≈ 1.17·2^128 ≈ 2^128 해시 계산이 필요합니다. 이것이 '생일 공격(birthday attack)'입니다. 실제 공격 시나리오: 공격자는 무작위 메시지 2^128개를 생성하여 해시 테이블에 저장하고, 충돌을 찾으면 두 메시지를 악의적으로 활용할 수 있습니다. 따라서 n비트 해시는 충돌 저항성에 대해 n/2비트 보안만 제공합니다. 이것이 SHA-256이 128비트 보안 강도를 가지는 이유이며, 128비트 보안이 필요하면 256비트 해시가 필요한 이유입니다.",
          "rationale_en": "Correct. Birthday paradox core: with 23 people, the probability that two share a birthday exceeds 50% (out of 365 days). This is counterintuitive but explained by √365 ≈ 19.1. Mathematically, for n possible hash values, collision probability P is approximated as P ≈ 1 - e^(-k^2/2n), and when P=0.5, k ≈ 1.17√n. For a 256-bit hash, n=2^256, so k ≈ 1.17·2^128 ≈ 2^128 hash calculations are needed. This is the 'birthday attack.' Real attack scenario: attacker generates 2^128 random messages, stores them in a hash table, and can maliciously use two messages if a collision is found. Therefore, an n-bit hash provides only n/2 bits of security for collision resistance. This is why SHA-256 has 128-bit security strength, and why 256-bit hash is needed for 128-bit security.",
          "isCorrect": true
        },
        {
          "text_ko": "256비트 해시에서 각 비트는 0 또는 1이므로, 충돌을 찾으려면 절반인 128비트만 확인하면 된다.",
          "text_en": "In a 256-bit hash, each bit is 0 or 1, so to find a collision you only need to check half, which is 128 bits.",
          "rationale_ko": "오답입니다. 학생이 비트 길이를 연산 횟수와 혼동하고 있습니다. '절반의 비트를 확인'한다는 것은 수학적으로 의미가 없습니다. 해시 함수의 출력 공간은 2^256개의 가능한 값이며, 각 값은 256비트로 표현됩니다. 충돌 공격의 복잡도는 출력 공간의 크기와 생일 역설의 확률적 분석에서 도출되며, 비트를 '절반만 확인'하는 것과는 무관합니다. 이 답변은 근본적인 수학적 이해가 부족함을 보여줍니다.",
          "rationale_en": "Incorrect. The student is confusing bit length with number of operations. 'Checking half the bits' is mathematically meaningless. The output space of a hash function has 2^256 possible values, each represented by 256 bits. Collision attack complexity is derived from the size of the output space and probabilistic analysis of the birthday paradox, unrelated to 'checking only half the bits.' This answer shows fundamental lack of mathematical understanding.",
          "isCorrect": false
        },
        {
          "text_ko": "생일 역설은 365일 중 같은 생일을 가진 사람이 있을 확률을 설명하는 것으로, 해시 충돌과는 무관하다. 2^128은 단순히 256의 절반이므로 절반의 노력으로 충돌을 찾을 수 있다는 경험적 규칙이다.",
          "text_en": "The birthday paradox explains the probability of people sharing a birthday among 365 days, unrelated to hash collisions. 2^128 is simply half of 256, so it's an empirical rule that half the effort finds a collision.",
          "rationale_ko": "오답입니다. 학생이 생일 역설의 응용을 이해하지 못하고 있습니다. 생일 역설은 암호학에서 충돌 공격의 복잡도를 분석하는 핵심 도구입니다. '365일 생일' 문제는 단지 설명 예시일 뿐이며, 동일한 수학적 원리가 모든 충돌 탐색 문제에 적용됩니다. 또한 '256의 절반'이라는 설명은 완전히 틀렸습니다—2^128은 256의 절반이 아니라 2^256의 제곱근입니다. 이것은 지수 연산을 선형 연산으로 잘못 이해한 것입니다. 2^256 / 2 = 2^255이며, 2^128은 √(2^256)입니다.",
          "rationale_en": "Incorrect. The student doesn't understand the application of the birthday paradox. The birthday paradox is a key tool for analyzing collision attack complexity in cryptography. The '365 days birthday' problem is just an illustrative example, and the same mathematical principle applies to all collision search problems. Also, the 'half of 256' explanation is completely wrong—2^128 is not half of 256 but the square root of 2^256. This is a misunderstanding of exponential operations as linear operations. 2^256 / 2 = 2^255, and 2^128 is √(2^256).",
          "isCorrect": false
        },
        {
          "text_ko": "256비트 해시 함수는 최대 2^256개의 입력을 처리할 수 있으므로, 그 절반인 2^128개 입력을 시도하면 비둘기집 원리에 의해 반드시 충돌이 발생한다.",
          "text_en": "A 256-bit hash function can process at most 2^256 inputs, so by pigeonhole principle, trying half that number (2^128 inputs) guarantees a collision.",
          "rationale_ko": "오답입니다. 학생이 여러 개념을 혼동하고 있습니다. 첫째, 해시 함수는 임의 길이의 입력을 받을 수 있으므로 입력 개수에 제한이 없습니다(무한한 입력 공간). 256비트는 출력 크기입니다. 둘째, 비둘기집 원리는 정확하지만 잘못 적용되었습니다. 비둘기집 원리에 따르면 2^256+1개의 입력을 해시하면 반드시 충돌이 발생하지만, 2^128개로는 충돌이 보장되지 않습니다—단지 높은 확률(약 50%)로 충돌이 발생할 뿐입니다. 이것이 생일 역설과 비둘기집 원리의 차이입니다. 생일 공격은 확률적이며, 보장이 아닌 기대값을 기반으로 합니다.",
          "rationale_en": "Incorrect. The student is confusing several concepts. First, hash functions can accept arbitrary length inputs, so there's no limit on input count (infinite input space). 256 bits is the output size. Second, the pigeonhole principle is correct but misapplied. By pigeonhole principle, hashing 2^256+1 inputs guarantees a collision, but 2^128 inputs don't guarantee collision—it just has a high probability (about 50%) of collision. This is the difference between birthday paradox and pigeonhole principle. Birthday attack is probabilistic, based on expected value rather than guarantee.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "'SHA-256(password)로 패스워드를 저장하는 것은 안전하다'는 주장이 거짓인 이유와, 솔팅(salting)이 왜 필요한지 설명하시오.",
      "question_en": "Explain why the claim 'SHA-256(password) is a secure way to store passwords' is false, and why salting is necessary.",
      "hint_ko": "공격자가 미리 많은 패스워드의 해시를 계산해두면 어떤 일이 발생하는지, 그리고 사용자별 고유한 값을 추가하면 어떻게 달라지는지 생각해보세요.",
      "hint_en": "Consider what happens if an attacker precomputes hashes of many passwords, and how adding user-specific unique values changes this.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Cryptographic Hash Functions - Password hashing and salting",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "솔트 없이 해시된 패스워드는 레인보우 테이블 공격에 취약하다. 공격자는 흔한 패스워드(예: 'password123')의 SHA-256 해시를 미리 계산하여 저장해두고, 데이터베이스 유출 시 즉시 매칭할 수 있다. 솔트(사용자별 랜덤 값)를 추가하면 SHA-256(password + salt)로 각 사용자마다 고유한 해시가 생성되어, 동일한 패스워드라도 해시가 달라지므로 사전 계산 공격이 불가능해진다.",
          "text_en": "Passwords hashed without salt are vulnerable to rainbow table attacks. Attackers can precompute and store SHA-256 hashes of common passwords (e.g., 'password123') and immediately match them when databases are breached. Adding salt (a random value per user) creates unique hashes via SHA-256(password + salt) for each user, so even identical passwords produce different hashes, making precomputation attacks impossible.",
          "rationale_ko": "정답입니다. 레인보우 테이블은 시간-메모리 트레이드오프 공격으로, 수백만 개의 일반적인 패스워드와 그 해시를 미리 계산하여 저장합니다. 예를 들어, 'password'의 SHA-256 해시는 항상 5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8입니다. 솔트가 없으면 이 패스워드를 사용하는 모든 사용자가 동일한 해시를 가지므로 한 번의 조회로 모두 크래킹됩니다. 솔트 적용 시: 사용자 A는 salt='a3f9', SHA-256('password'+'a3f9'), 사용자 B는 salt='x7k2', SHA-256('password'+'x7k2')로 완전히 다른 해시를 저장합니다. 공격자는 각 솔트에 대해 별도로 레인보우 테이블을 생성해야 하므로 비용이 기하급수적으로 증가합니다. 솔트는 비밀이 아니며 해시와 함께 저장되지만, 사전 계산을 방지하는 효과가 있습니다. 참고로 솔트만으로는 무차별 대입 공격을 막을 수 없으므로, bcrypt나 Argon2 같은 느린 해시 함수를 함께 사용해야 합니다.",
          "rationale_en": "Correct. Rainbow tables are time-memory tradeoff attacks that precompute and store millions of common passwords and their hashes. For example, SHA-256 hash of 'password' is always 5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8. Without salt, all users with this password have identical hash, allowing cracking with a single lookup. With salt: user A has salt='a3f9', SHA-256('password'+'a3f9'), user B has salt='x7k2', SHA-256('password'+'x7k2'), storing completely different hashes. Attackers must generate separate rainbow tables for each salt, making cost exponentially higher. Salt is not secret and is stored with the hash, but prevents precomputation. Note that salt alone cannot prevent brute force attacks, so slow hash functions like bcrypt or Argon2 should be used together.",
          "isCorrect": true
        },
        {
          "text_ko": "SHA-256은 암호학적 해시 함수가 아니므로 패스워드 저장에 부적합하다. 솔팅은 SHA-256을 암호학적으로 안전하게 만들기 위한 기법이다.",
          "text_en": "SHA-256 is not a cryptographic hash function, so it's unsuitable for password storage. Salting is a technique to make SHA-256 cryptographically secure.",
          "rationale_ko": "오답입니다. 학생이 근본적인 사실을 잘못 이해하고 있습니다. SHA-256은 NIST FIPS 180-4에 의해 표준화된 암호학적 해시 함수입니다. 충돌 저항성, 원상 저항성, 제2 원상 저항성을 모두 만족합니다. 솔팅은 SHA-256을 '암호학적으로 만드는' 것이 아니라, 동일한 입력에 대해 동일한 출력이 생성되는 해시 함수의 결정론적(deterministic) 특성을 극복하기 위한 기법입니다. SHA-256 자체는 이미 안전하지만, 패스워드 저장이라는 특수한 상황에서 사전 계산 공격을 방지하기 위해 솔트가 필요한 것입니다.",
          "rationale_en": "Incorrect. The student fundamentally misunderstands facts. SHA-256 is a cryptographic hash function standardized by NIST FIPS 180-4. It satisfies collision resistance, preimage resistance, and second preimage resistance. Salting doesn't 'make SHA-256 cryptographic' but overcomes the deterministic characteristic of hash functions that produce identical outputs for identical inputs. SHA-256 itself is already secure, but salt is needed to prevent precomputation attacks in the specific context of password storage.",
          "isCorrect": false
        },
        {
          "text_ko": "SHA-256은 너무 빠르므로 공격자가 초당 수십억 개의 패스워드를 시도할 수 있다. 솔팅은 해시 계산 속도를 늦춰서 무차별 대입 공격을 어렵게 만든다.",
          "text_en": "SHA-256 is too fast, allowing attackers to try billions of passwords per second. Salting slows down hash computation, making brute force attacks harder.",
          "rationale_ko": "오답입니다. 학생이 솔팅과 키 스트레칭(key stretching)을 혼동하고 있습니다. 솔트는 해시 계산 속도를 늦추지 않습니다—SHA-256(password+salt)는 SHA-256(password)와 동일한 속도입니다. 솔트의 목적은 사전 계산 방지이지 속도 저하가 아닙니다. 속도를 늦추는 것은 bcrypt, scrypt, Argon2 같은 알고리즘의 work factor(또는 cost parameter)입니다. 예를 들어, bcrypt는 내부적으로 반복 횟수를 설정하여 의도적으로 느리게 만듭니다. 학생의 첫 번째 관찰(SHA-256이 너무 빠름)은 맞지만, 솔트가 이를 해결하는 것이 아니라 느린 해시 함수가 해결합니다.",
          "rationale_en": "Incorrect. The student is confusing salting with key stretching. Salt does not slow down hash computation—SHA-256(password+salt) is the same speed as SHA-256(password). Salt's purpose is preventing precomputation, not slowing down speed. Speed reduction is achieved by work factor (or cost parameter) of algorithms like bcrypt, scrypt, Argon2. For example, bcrypt sets iteration count internally to intentionally slow down. The student's first observation (SHA-256 is too fast) is correct, but salt doesn't solve this—slow hash functions do.",
          "isCorrect": false
        },
        {
          "text_ko": "솔트 없이는 해시 값만으로 원본 패스워드를 역계산할 수 있지만, 솔트를 추가하면 역계산이 수학적으로 불가능해진다.",
          "text_en": "Without salt, the original password can be reverse-computed from the hash alone, but adding salt makes reverse computation mathematically impossible.",
          "rationale_ko": "오답입니다. 학생이 해시 함수의 일방향성과 솔트의 역할을 혼동하고 있습니다. SHA-256은 솔트 여부와 무관하게 일방향 함수(one-way function)이므로 해시에서 원본을 직접 역계산하는 것은 계산적으로 불가능합니다. 솔트가 없어도 SHA-256의 원상 저항성은 2^256 복잡도를 가집니다. 솔트의 역할은 역계산 방지가 아니라, 사전 계산된 해시 테이블의 재사용을 방지하는 것입니다. 솔트가 있어도 공격자는 여전히 무차별 대입으로 패스워드를 찾을 수 있습니다(각 솔트에 대해 개별적으로). 차이는 사전 계산의 가능 여부입니다.",
          "rationale_en": "Incorrect. The student is confusing the one-way property of hash functions with salt's role. SHA-256 is a one-way function regardless of salt, making direct reverse computation from hash computationally infeasible. Even without salt, SHA-256's preimage resistance has 2^256 complexity. Salt's role is not preventing reverse computation but preventing reuse of precomputed hash tables. Even with salt, attackers can still find passwords through brute force (individually for each salt). The difference is whether precomputation is possible.",
          "isCorrect": false
        }
      ]
    }
  ]
  