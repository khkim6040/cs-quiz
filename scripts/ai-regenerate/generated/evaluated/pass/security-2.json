[
    {
      "question_ko": "AES의 ECB(Electronic Codebook) 모드에서 동일한 평문 블록 두 개를 암호화하면 어떤 결과가 나타나는가?",
      "question_en": "What happens when two identical plaintext blocks are encrypted using AES in ECB (Electronic Codebook) mode?",
      "hint_ko": "ECB 모드는 각 블록을 독립적으로 암호화한다는 점을 떠올려 보세요.",
      "hint_en": "Think about how ECB mode encrypts each block independently.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Symmetric Encryption (AES, DES)",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "동일한 암호문 블록 두 개가 생성된다",
          "text_en": "Two identical ciphertext blocks are produced",
          "rationale_ko": "ECB 모드는 각 블록을 동일한 키로 독립적으로 암호화하므로, 같은 평문 블록은 항상 같은 암호문 블록을 생성합니다. 이 때문에 패턴이 유출되어 기밀성이 약해집니다.",
          "rationale_en": "ECB mode encrypts each block independently with the same key, so identical plaintext blocks always produce identical ciphertext blocks. This leaks patterns and weakens confidentiality.",
          "isCorrect": true
        },
        {
          "text_ko": "서로 다른 암호문 블록 두 개가 생성된다",
          "text_en": "Two different ciphertext blocks are produced",
          "rationale_ko": "CBC 모드에서는 이전 암호문 블록이 다음 블록의 암호화에 영향을 주어 동일한 평문도 다른 암호문이 됩니다. 그러나 ECB 모드는 블록 간 체이닝이 없으므로 동일한 평문은 동일한 암호문을 생성합니다.",
          "rationale_en": "In CBC mode, the previous ciphertext block affects the next encryption, producing different ciphertexts even for identical plaintexts. However, ECB has no chaining between blocks, so identical plaintexts yield identical ciphertexts.",
          "isCorrect": false
        },
        {
          "text_ko": "암호화가 실패하고 오류가 발생한다",
          "text_en": "Encryption fails and an error occurs",
          "rationale_ko": "ECB 모드는 동일한 평문 블록을 암호화하는 데 아무런 문제가 없습니다. 오류 없이 정상적으로 암호화되지만, 결과의 패턴이 보안상 취약점이 됩니다.",
          "rationale_en": "ECB mode has no problem encrypting identical plaintext blocks. Encryption proceeds without errors, but the resulting patterns create a security weakness.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "RSA를 사용하여 대용량 파일을 직접 암호화하지 않는 이유는 무엇인가?",
      "question_en": "Why is RSA not used to directly encrypt large files?",
      "hint_ko": "RSA의 연산 속도와 블록 크기 제한을 생각해 보세요.",
      "hint_en": "Consider RSA's computation speed and block size limitations.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Asymmetric Encryption (RSA, ECC)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "RSA는 대칭키 암호보다 연산이 매우 느리고, 한 번에 암호화할 수 있는 데이터 크기가 키 크기보다 작기 때문이다",
          "text_en": "RSA is computationally much slower than symmetric encryption and can only encrypt data smaller than the key size at a time",
          "rationale_ko": "RSA는 모듈러 지수 연산을 사용하므로 AES 같은 대칭키 암호보다 수백~수천 배 느립니다. 또한 RSA-2048은 한 번에 최대 256바이트(패딩 포함 시 더 적음)만 암호화할 수 있어 대용량 데이터에 비효율적입니다.",
          "rationale_en": "RSA uses modular exponentiation, making it hundreds to thousands of times slower than symmetric ciphers like AES. Additionally, RSA-2048 can only encrypt up to 256 bytes at a time (less with padding), making it impractical for large data.",
          "isCorrect": true
        },
        {
          "text_ko": "RSA는 텍스트만 암호화할 수 있고 바이너리 데이터는 처리하지 못하기 때문이다",
          "text_en": "RSA can only encrypt text and cannot handle binary data",
          "rationale_ko": "RSA는 수학적 연산이므로 입력을 정수로 변환하여 처리합니다. 텍스트든 바이너리든 상관없이 암호화할 수 있습니다. 제한은 데이터 유형이 아니라 크기와 속도에 있습니다.",
          "rationale_en": "RSA is a mathematical operation that converts inputs to integers for processing. It can encrypt both text and binary data. The limitation is in size and speed, not data type.",
          "isCorrect": false
        },
        {
          "text_ko": "RSA로 암호화된 파일은 복호화가 불가능하기 때문이다",
          "text_en": "Files encrypted with RSA cannot be decrypted",
          "rationale_ko": "RSA로 암호화된 데이터는 대응하는 개인키로 정상적으로 복호화할 수 있습니다. 복호화가 불가능한 것이 아니라, 속도와 크기 제한 때문에 실용적이지 않을 뿐입니다.",
          "rationale_en": "Data encrypted with RSA can be properly decrypted with the corresponding private key. It's not that decryption is impossible, but rather that RSA is impractical for large files due to speed and size constraints.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "SHA-256(password)만으로 패스워드를 저장하면 레인보우 테이블(Rainbow Table) 공격에 취약하지만, 솔트(salt)를 추가하면 이 공격을 완전히 방어할 수 있다.",
      "question_en": "Storing passwords as SHA-256(password) is vulnerable to rainbow table attacks, but adding a salt completely defends against this attack.",
      "hint_ko": "솔트는 사전 계산된 테이블을 무력화하지만, 개별 패스워드에 대한 무차별 대입까지 막지는 못합니다.",
      "hint_en": "Salt neutralizes precomputed tables, but consider whether it stops brute force on individual passwords.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Cryptographic Hash Functions (SHA-256, MD5)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "솔트를 추가하면 레인보우 테이블 공격은 효과적으로 방어할 수 있습니다. 그러나 SHA-256은 매우 빠른 해시 함수이기 때문에, 공격자가 개별 패스워드에 대해 무차별 대입(brute force) 공격을 수행하는 것은 여전히 가능합니다. 따라서 '완전히 방어'한다는 표현은 정확하지 않습니다.",
          "rationale_en": "Adding salt effectively defends against rainbow table attacks. However, SHA-256 is a very fast hash function, so attackers can still perform brute force attacks against individual passwords. Therefore, 'completely defends' is not accurate.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "솔트는 레인보우 테이블(사전 계산된 해시 테이블)을 무력화하여 해당 공격을 방어합니다. 하지만 SHA-256은 초당 수십억 번 연산이 가능할 정도로 빠르기 때문에, 솔트가 있어도 짧거나 약한 패스워드는 무차별 대입으로 뚫릴 수 있습니다. bcrypt 같은 느린 해시 함수가 더 안전합니다.",
          "rationale_en": "Salt neutralizes rainbow tables (precomputed hash tables), defending against that specific attack. However, SHA-256 can compute billions of hashes per second, so even with salt, short or weak passwords can be cracked by brute force. Slow hash functions like bcrypt are more secure.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "HMAC은 대칭키를 사용하므로 부인 방지(Non-repudiation)를 제공하지 않지만, 개인키로 서명하는 RSA 디지털 서명은 부인 방지를 제공한다.",
      "question_en": "HMAC does not provide non-repudiation because it uses a symmetric key, whereas RSA digital signatures provide non-repudiation because they use a private key for signing.",
      "hint_ko": "대칭키는 송신자와 수신자가 동일한 키를 공유한다는 점을 생각해 보세요.",
      "hint_en": "Consider that a symmetric key is shared between both the sender and receiver.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Digital Signatures and MACs",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "HMAC에서는 송신자와 수신자가 동일한 비밀키를 공유하므로, 수신자도 동일한 HMAC 값을 생성할 수 있어 누가 메시지를 보냈는지 제3자에게 증명할 수 없습니다. 반면 RSA 서명은 서명자만 가진 개인키로 서명하고, 누구나 공개키로 검증할 수 있으므로 부인 방지가 가능합니다.",
          "rationale_en": "In HMAC, both sender and receiver share the same secret key, so the receiver could also generate the same HMAC value, making it impossible to prove to a third party who sent the message. RSA signatures use a private key known only to the signer, and anyone can verify with the public key, enabling non-repudiation.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 사실입니다. HMAC은 공유 비밀키를 사용하기 때문에 송신자와 수신자 모두 동일한 MAC 값을 생성할 수 있어 부인 방지가 불가능합니다. RSA 디지털 서명은 개인키의 고유성 덕분에 서명자를 특정할 수 있어 부인 방지를 제공합니다.",
          "rationale_en": "This statement is correct. HMAC uses a shared secret key, so both parties can generate the same MAC value, making non-repudiation impossible. RSA digital signatures leverage the uniqueness of the private key, allowing identification of the signer and providing non-repudiation.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TLS는 TCP/IP 패킷의 헤더를 포함한 전체 패킷을 암호화한다.",
      "question_en": "TLS encrypts the entire TCP/IP packet, including headers.",
      "hint_ko": "TLS가 OSI 모델의 어느 계층에서 동작하는지 생각해 보세요.",
      "hint_en": "Think about which layer of the OSI model TLS operates at.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "TLS/SSL Handshake Protocol",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "TLS는 전송 계층(Transport Layer) 위에서 동작하므로 TCP/IP 헤더는 암호화하지 않습니다. IP 주소와 포트 번호 같은 정보는 라우팅을 위해 평문으로 남아야 합니다. TLS는 애플리케이션 데이터(페이로드)만 암호화합니다.",
          "rationale_en": "TLS operates above the transport layer, so it does not encrypt TCP/IP headers. Information like IP addresses and port numbers must remain in plaintext for routing. TLS only encrypts the application data (payload).",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "TLS는 애플리케이션 계층의 데이터만 암호화하며, TCP 헤더와 IP 헤더는 네트워크 라우팅을 위해 암호화되지 않습니다. 따라서 공격자는 통신 상대와 포트 번호 등의 메타데이터를 여전히 관찰할 수 있습니다.",
          "rationale_en": "TLS only encrypts application-layer data. TCP and IP headers remain unencrypted for network routing purposes. Attackers can still observe metadata such as communication endpoints and port numbers.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "네트워크 경계에 배치된 방화벽은 외부에서 내부로의 공격을 차단하는 데 효과적이지만, 이미 내부 네트워크에 접근 권한이 있는 내부자 위협에는 대응하지 못한다.",
      "question_en": "A firewall placed at the network perimeter is effective at blocking external attacks but cannot address insider threats from those who already have access to the internal network.",
      "hint_ko": "방화벽이 주로 어떤 트래픽을 제어하는지 생각해 보세요.",
      "hint_en": "Consider what type of traffic a perimeter firewall primarily controls.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Firewalls and Packet Filtering",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "네트워크 경계의 방화벽은 외부 트래픽을 필터링하는 데 효과적이지만, 내부자가 이미 네트워크 내부에서 행동하므로 경계 방화벽을 통과하지 않습니다. 내부자 위협에는 네트워크 세분화, 접근 제어, 모니터링 등 추가적인 보안 조치가 필요합니다.",
          "rationale_en": "A perimeter firewall effectively filters external traffic, but insiders already operate within the network and bypass the perimeter firewall. Insider threats require additional measures such as network segmentation, access control, and monitoring.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 사실입니다. 경계 방화벽의 주요 기능은 외부-내부 트래픽 제어이며, 내부 네트워크 안에서 발생하는 내부자 행위는 경계 방화벽의 관할 범위를 벗어납니다.",
          "rationale_en": "This statement is factually correct. The primary function of perimeter firewalls is external-internal traffic control, and insider activities within the internal network fall outside the perimeter firewall's scope.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "침입 탐지 시스템(IDS)은 네트워크 트래픽을 모니터링하고 의심스러운 활동을 경고하지만, 트래픽을 직접 차단하는 것은 침입 방지 시스템(IPS)의 역할이다.",
      "question_en": "An Intrusion Detection System (IDS) monitors network traffic and alerts on suspicious activity, but directly blocking traffic is the role of an Intrusion Prevention System (IPS).",
      "hint_ko": "이름에서 'Detection'과 'Prevention'의 의미를 생각해 보세요.",
      "hint_en": "Think about what 'Detection' and 'Prevention' mean in the names.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Intrusion Detection Systems (IDS/IPS)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "IDS는 트래픽을 수동적으로 모니터링하고 의심스러운 패턴을 발견하면 관리자에게 경고합니다. IPS는 IDS의 기능에 더해 탐지된 위협을 실시간으로 차단하는 능동적 방어 기능을 수행합니다. 이 구분은 보안 아키텍처 설계에서 중요합니다.",
          "rationale_en": "IDS passively monitors traffic and alerts administrators when suspicious patterns are found. IPS performs active defense by blocking detected threats in real-time in addition to IDS functions. This distinction is important in security architecture design.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 정확합니다. IDS의 역할은 탐지와 경고에 한정되며, 실시간 차단은 IPS만의 기능입니다. 많은 학생들이 IDS와 IPS의 차이를 혼동하지만, 탐지(Detection)와 방지(Prevention)는 명확히 구분되는 기능입니다.",
          "rationale_en": "This statement is accurate. IDS is limited to detection and alerting, while real-time blocking is exclusively an IPS function. Many students confuse IDS and IPS, but detection and prevention are clearly distinct functions.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "VPN을 사용하면 사용자의 인터넷 활동에 대한 완전한 익명성이 보장된다.",
      "question_en": "Using a VPN guarantees complete anonymity for a user's internet activity.",
      "hint_ko": "VPN 제공자가 어떤 정보를 볼 수 있는지 생각해 보세요.",
      "hint_en": "Think about what information the VPN provider can see.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "VPN and Tunneling Protocols (IPsec, WireGuard)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "VPN은 사용자와 VPN 서버 간의 트래픽을 암호화하지만, VPN 제공자는 사용자의 원래 IP 주소와 접속 시간, 접속 대상 서버 등의 정보를 확인할 수 있습니다. 또한 웹사이트의 쿠키, 브라우저 핑거프린팅 등으로 사용자를 추적할 수 있습니다.",
          "rationale_en": "VPN encrypts traffic between the user and VPN server, but the VPN provider can see the user's original IP address, connection times, and destination servers. Users can also be tracked through website cookies, browser fingerprinting, and other techniques.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "VPN은 ISP로부터 트래픽을 숨기고 IP 주소를 변경하지만, VPN 제공자 자체는 사용자의 트래픽 메타데이터를 볼 수 있습니다. 또한 DNS 유출, 쿠키 추적, 브라우저 핑거프린팅 등 여러 기법으로 사용자를 식별할 수 있어 완전한 익명성은 보장되지 않습니다.",
          "rationale_en": "VPN hides traffic from the ISP and changes the IP address, but the VPN provider itself can see the user's traffic metadata. Users can also be identified through DNS leaks, cookie tracking, browser fingerprinting, and other methods, so complete anonymity is not guaranteed.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "DNSSEC은 DNS 응답의 무결성과 인증을 제공하지만, DNS 쿼리의 기밀성(암호화)은 제공하지 않는다.",
      "question_en": "DNSSEC provides integrity and authentication of DNS responses, but does not provide confidentiality (encryption) of DNS queries.",
      "hint_ko": "DNSSEC이 디지털 서명을 사용한다는 점을 기억하세요. 서명과 암호화는 다릅니다.",
      "hint_en": "Remember that DNSSEC uses digital signatures. Signing and encryption are different.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "DNS Security and DNSSEC",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "DNSSEC은 RRSIG 레코드를 통해 DNS 응답에 디지털 서명을 추가하여 응답의 무결성과 출처를 검증합니다. 그러나 DNS 쿼리와 응답 자체를 암호화하지는 않으므로 도청(eavesdropping)은 여전히 가능합니다. DNS 트래픽 암호화는 DNS over HTTPS(DoH)나 DNS over TLS(DoT)가 담당합니다.",
          "rationale_en": "DNSSEC adds digital signatures to DNS responses via RRSIG records, verifying response integrity and origin. However, it does not encrypt DNS queries or responses, so eavesdropping is still possible. DNS traffic encryption is handled by DNS over HTTPS (DoH) or DNS over TLS (DoT).",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "DNSSEC은 실제로 암호화를 제공하지 않습니다. DNSSEC의 역할은 디지털 서명을 통한 인증과 무결성 보장에 한정됩니다. DNS 트래픽의 기밀성을 위해서는 DoH나 DoT 같은 별도의 프로토콜이 필요합니다.",
          "rationale_en": "DNSSEC does not actually provide encryption. Its role is limited to authentication and integrity through digital signatures. Separate protocols like DoH or DoT are needed for DNS traffic confidentiality.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "SQL 인젝션(SQL Injection) 공격을 방어하기 위해 가장 효과적인 방법은 무엇인가?",
      "question_en": "What is the most effective method to defend against SQL Injection attacks?",
      "hint_ko": "쿼리의 구조와 데이터를 분리하는 방법을 생각해 보세요.",
      "hint_en": "Think about a method that separates query structure from data.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "SQL Injection Attacks",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "매개변수화된 쿼리(Prepared Statement)를 사용한다",
          "text_en": "Use parameterized queries (Prepared Statements)",
          "rationale_ko": "매개변수화된 쿼리는 SQL 문의 구조와 사용자 입력 데이터를 완전히 분리합니다. 데이터베이스 엔진이 쿼리 구조를 먼저 컴파일한 후 매개변수 값을 바인딩하므로, 사용자 입력이 SQL 명령으로 해석될 수 없습니다.",
          "rationale_en": "Parameterized queries completely separate SQL statement structure from user input data. The database engine compiles the query structure first and then binds parameter values, so user input cannot be interpreted as SQL commands.",
          "isCorrect": true
        },
        {
          "text_ko": "사용자 입력에서 작은따옴표(')를 모두 제거한다",
          "text_en": "Remove all single quotes (') from user input",
          "rationale_ko": "작은따옴표 제거는 일부 SQL 인젝션을 방어할 수 있지만, 숫자형 필드에서의 인젝션이나 인코딩 우회 기법(예: URL 인코딩, 유니코드)으로 쉽게 무력화됩니다. 블랙리스트 기반 필터링은 근본적인 해결책이 아닙니다.",
          "rationale_en": "Removing single quotes may block some SQL injections, but it can be easily bypassed through numeric field injections or encoding techniques (e.g., URL encoding, Unicode). Blacklist-based filtering is not a fundamental solution.",
          "isCorrect": false
        },
        {
          "text_ko": "클라이언트 측 JavaScript로 입력값을 검증한다",
          "text_en": "Validate input with client-side JavaScript",
          "rationale_ko": "클라이언트 측 검증은 사용자 편의를 위한 것이며, 공격자는 브라우저를 우회하여 직접 서버에 요청을 보낼 수 있습니다. 따라서 보안 목적의 입력 검증은 반드시 서버 측에서 수행해야 합니다.",
          "rationale_en": "Client-side validation is for user convenience. Attackers can bypass the browser and send requests directly to the server. Therefore, input validation for security purposes must be performed on the server side.",
          "isCorrect": false
        },
        {
          "text_ko": "웹 애플리케이션 방화벽(WAF)을 설치한다",
          "text_en": "Install a Web Application Firewall (WAF)",
          "rationale_ko": "WAF는 알려진 SQL 인젝션 패턴을 탐지하여 차단할 수 있지만, 새로운 우회 기법에 취약할 수 있습니다. WAF는 추가적인 방어 계층으로 유용하지만, 매개변수화된 쿼리처럼 근본적인 해결책을 대체할 수 없습니다.",
          "rationale_en": "WAF can detect and block known SQL injection patterns but may be vulnerable to new bypass techniques. WAF is useful as an additional defense layer but cannot replace fundamental solutions like parameterized queries.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "다음 중 XSS(Cross-Site Scripting)의 세 가지 유형을 올바르게 설명한 것은?",
      "question_en": "Which of the following correctly describes the three types of XSS (Cross-Site Scripting)?",
      "hint_ko": "악성 스크립트가 어디에 저장되고 어떻게 실행되는지에 따라 유형이 나뉩니다.",
      "hint_en": "Types are classified based on where the malicious script is stored and how it is executed.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Cross-Site Scripting (XSS)",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "반사형(Reflected)은 URL을 통해 전달되어 즉시 실행되고, 저장형(Stored)은 서버 데이터베이스에 저장되어 다른 사용자에게도 실행되며, DOM 기반은 서버를 거치지 않고 클라이언트 측 JavaScript에서 발생한다",
          "text_en": "Reflected is delivered via URL and executed immediately, Stored is saved in the server database and executed for other users, and DOM-based occurs in client-side JavaScript without going through the server",
          "rationale_ko": "반사형 XSS는 악성 스크립트가 URL 매개변수 등을 통해 서버에 전달된 후 응답에 포함되어 실행됩니다. 저장형 XSS는 서버 DB에 악성 스크립트가 저장되어 해당 페이지를 방문하는 모든 사용자에게 실행됩니다. DOM 기반 XSS는 서버 응답과 무관하게 클라이언트 측 DOM 조작에서 발생합니다.",
          "rationale_en": "Reflected XSS occurs when a malicious script is sent to the server via URL parameters and included in the response. Stored XSS saves the malicious script in the server DB, executing it for all users visiting the page. DOM-based XSS occurs through client-side DOM manipulation regardless of the server response.",
          "isCorrect": true
        },
        {
          "text_ko": "반사형은 서버 DB에 저장되고, 저장형은 URL을 통해 전달되며, DOM 기반은 서버 측 렌더링에서 발생한다",
          "text_en": "Reflected is stored in the server DB, Stored is delivered via URL, and DOM-based occurs in server-side rendering",
          "rationale_ko": "이 설명은 반사형과 저장형의 정의가 뒤바뀌어 있습니다. 반사형은 URL을 통해 전달되어 즉시 실행되고, 저장형이 서버 DB에 저장됩니다. DOM 기반은 클라이언트 측에서 발생하지 서버 측 렌더링에서 발생하지 않습니다.",
          "rationale_en": "This description swaps the definitions of reflected and stored XSS. Reflected is delivered via URL and executed immediately, while stored is saved in the server DB. DOM-based occurs on the client side, not in server-side rendering.",
          "isCorrect": false
        },
        {
          "text_ko": "세 유형 모두 서버 데이터베이스에 악성 코드가 저장되며, 실행 시점만 다르다",
          "text_en": "All three types store malicious code in the server database, differing only in execution timing",
          "rationale_ko": "서버 DB에 저장되는 것은 저장형 XSS만 해당합니다. 반사형은 서버에 저장되지 않고 즉시 응답에 반영되며, DOM 기반은 서버를 전혀 거치지 않을 수 있습니다. 세 유형의 핵심 차이는 스크립트의 전달 경로와 실행 메커니즘입니다.",
          "rationale_en": "Only stored XSS involves saving in the server DB. Reflected XSS is immediately reflected in the response without storage, and DOM-based may not involve the server at all. The key difference between the three types is the delivery path and execution mechanism of the script.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "CSRF(Cross-Site Request Forgery) 공격에서 악성 사이트는 피해자의 쿠키를 직접 탈취하지 않아도, 브라우저가 자동으로 포함하는 쿠키를 이용하여 인증된 요청을 보낼 수 있다.",
      "question_en": "In a CSRF (Cross-Site Request Forgery) attack, a malicious site can send authenticated requests using cookies that the browser automatically includes, without directly stealing the victim's cookies.",
      "hint_ko": "브라우저의 쿠키 전송 규칙과 '주변 권한(ambient authority)'의 개념을 생각해 보세요.",
      "hint_en": "Think about the browser's cookie sending rules and the concept of 'ambient authority.'",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Cross-Site Request Forgery (CSRF)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "CSRF 공격은 브라우저의 '주변 권한(ambient authority)' 특성을 악용합니다. 브라우저는 요청의 출처에 관계없이 대상 도메인의 쿠키를 자동으로 첨부하므로, 공격자가 악성 페이지에서 피해자의 브라우저를 통해 은행 등의 사이트에 요청을 보내면 인증 쿠키가 자동으로 포함됩니다.",
          "rationale_en": "CSRF attacks exploit the browser's 'ambient authority' property. Browsers automatically attach cookies for the target domain regardless of the request's origin, so when an attacker sends a request through the victim's browser from a malicious page to a site like a bank, authentication cookies are automatically included.",
          "isCorrect": true
        },
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "이 문장은 정확합니다. CSRF 공격의 핵심은 브라우저가 특정 도메인에 대한 요청 시 해당 도메인의 쿠키를 자동으로 포함한다는 점입니다. 공격자는 쿠키를 훔칠 필요 없이, 브라우저의 이 동작을 악용하여 피해자의 인증된 세션으로 요청을 보낼 수 있습니다.",
          "rationale_en": "This statement is correct. The core of CSRF attacks is that browsers automatically include cookies for a domain when making requests to it. Attackers don't need to steal cookies; they exploit this browser behavior to send requests using the victim's authenticated session.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "쿠키의 HttpOnly, Secure, SameSite=Strict 속성 중 XSS를 통한 세션 탈취를 직접적으로 방지하는 것은 무엇인가?",
      "question_en": "Among the cookie attributes HttpOnly, Secure, and SameSite=Strict, which one directly prevents session theft via XSS?",
      "hint_ko": "XSS 공격에서 JavaScript를 사용하여 쿠키에 접근하는 방식을 생각해 보세요.",
      "hint_en": "Think about how XSS attacks use JavaScript to access cookies.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Session Management and Cookies",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "HttpOnly",
          "text_en": "HttpOnly",
          "rationale_ko": "HttpOnly 플래그가 설정된 쿠키는 JavaScript의 document.cookie를 통해 접근할 수 없습니다. XSS 공격에서 공격자가 주입한 스크립트가 쿠키를 읽으려 해도 접근이 차단되므로, 세션 토큰 탈취를 직접적으로 방지합니다.",
          "rationale_en": "Cookies with the HttpOnly flag cannot be accessed through JavaScript's document.cookie. Even if an attacker's injected script attempts to read cookies in an XSS attack, access is blocked, directly preventing session token theft.",
          "isCorrect": true
        },
        {
          "text_ko": "Secure",
          "text_en": "Secure",
          "rationale_ko": "Secure 플래그는 쿠키가 HTTPS 연결에서만 전송되도록 합니다. 이는 네트워크 도청을 방지하지만, XSS 공격은 이미 브라우저 내부에서 발생하므로 Secure 플래그로는 XSS를 통한 세션 탈취를 방지할 수 없습니다.",
          "rationale_en": "The Secure flag ensures cookies are only sent over HTTPS connections. This prevents network eavesdropping, but since XSS attacks occur within the browser itself, the Secure flag cannot prevent session theft via XSS.",
          "isCorrect": false
        },
        {
          "text_ko": "SameSite=Strict",
          "text_en": "SameSite=Strict",
          "rationale_ko": "SameSite=Strict는 다른 사이트에서 발생한 요청에 쿠키를 포함하지 않도록 하여 CSRF 공격을 방어합니다. 그러나 XSS 공격은 같은 사이트 내에서 실행되는 스크립트이므로 SameSite 속성으로는 XSS를 통한 쿠키 접근을 차단할 수 없습니다.",
          "rationale_en": "SameSite=Strict prevents cookies from being included in requests from other sites, defending against CSRF attacks. However, XSS attacks execute scripts within the same site, so the SameSite attribute cannot block cookie access via XSS.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "Content Security Policy(CSP) 헤더에 'unsafe-inline'을 포함하면 CSP의 XSS 방어 효과가 크게 약화된다.",
      "question_en": "Including 'unsafe-inline' in the Content Security Policy (CSP) header significantly weakens CSP's defense against XSS.",
      "hint_ko": "인라인 스크립트가 XSS 공격에서 어떻게 활용되는지 생각해 보세요.",
      "hint_en": "Think about how inline scripts are used in XSS attacks.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Content Security Policy (CSP)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "CSP의 핵심 보안 기능 중 하나는 인라인 스크립트 실행을 차단하는 것입니다. 'unsafe-inline'을 허용하면 공격자가 주입한 인라인 <script> 태그나 이벤트 핸들러가 실행될 수 있어 XSS 방어 효과가 크게 약화됩니다. 대신 nonce 기반 접근 방식을 사용해야 합니다.",
          "rationale_en": "One of CSP's core security features is blocking inline script execution. Allowing 'unsafe-inline' means attacker-injected inline <script> tags or event handlers can execute, significantly weakening XSS defense. A nonce-based approach should be used instead.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "'unsafe-inline'은 실제로 CSP의 XSS 방어를 크게 약화시킵니다. XSS 공격의 가장 일반적인 형태가 인라인 스크립트 주입이므로, 이를 허용하면 CSP 도입의 주요 목적이 무효화됩니다.",
          "rationale_en": "'unsafe-inline' does significantly weaken CSP's XSS defense. Since inline script injection is the most common form of XSS attack, allowing it defeats the primary purpose of implementing CSP.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "패스워드 저장에 SHA-256 대신 bcrypt가 권장되는 주된 이유는 무엇인가?",
      "question_en": "What is the main reason bcrypt is recommended over SHA-256 for password storage?",
      "hint_ko": "두 알고리즘의 연산 속도 차이를 생각해 보세요.",
      "hint_en": "Consider the difference in computation speed between the two algorithms.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Password Hashing and Storage",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "bcrypt는 출력 길이가 SHA-256보다 길어서 더 안전하기 때문이다",
          "text_en": "Because bcrypt has a longer output length than SHA-256, making it more secure",
          "rationale_ko": "해시 출력 길이는 패스워드 저장의 보안성에 결정적인 요소가 아닙니다. bcrypt의 출력 길이(184비트)는 SHA-256(256비트)보다 오히려 짧습니다. bcrypt의 장점은 출력 길이가 아니라 의도적으로 느린 연산 속도에 있습니다.",
          "rationale_en": "Hash output length is not a decisive factor in password storage security. bcrypt's output (184 bits) is actually shorter than SHA-256 (256 bits). bcrypt's advantage lies in its intentionally slow computation speed, not output length.",
          "isCorrect": false
        },
        {
          "text_ko": "bcrypt는 의도적으로 느리게 설계되어 무차별 대입 공격의 비용을 크게 증가시키기 때문이다",
          "text_en": "Because bcrypt is intentionally designed to be slow, greatly increasing the cost of brute force attacks",
          "rationale_ko": "bcrypt는 비용 인자(cost factor)를 통해 해싱 속도를 조절할 수 있습니다. SHA-256은 초당 수십억 번 연산이 가능하지만, bcrypt는 비용 인자를 높여 한 번의 해시 연산에 수백 밀리초가 걸리게 할 수 있어, 무차별 대입 공격에 필요한 시간과 비용을 기하급수적으로 증가시킵니다.",
          "rationale_en": "bcrypt allows adjusting hashing speed through a cost factor. While SHA-256 can compute billions of hashes per second, bcrypt can be configured to take hundreds of milliseconds per hash operation, exponentially increasing the time and cost required for brute force attacks.",
          "isCorrect": true
        },
        {
          "text_ko": "SHA-256은 알려진 취약점이 있어 충돌이 쉽게 발견되기 때문이다",
          "text_en": "Because SHA-256 has known vulnerabilities that allow easy collision discovery",
          "rationale_ko": "SHA-256은 현재까지 실질적인 충돌 취약점이 발견되지 않은 안전한 해시 함수입니다. SHA-256이 패스워드 저장에 부적합한 이유는 충돌 취약점이 아니라 너무 빠른 연산 속도 때문입니다.",
          "rationale_en": "SHA-256 is a secure hash function with no practical collision vulnerabilities discovered to date. The reason SHA-256 is unsuitable for password storage is not collision vulnerability but its extremely fast computation speed.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "패스워드와 보안 질문은 모두 '알고 있는 것(something you know)' 범주에 속하므로, 이 둘을 함께 사용하는 것은 진정한 2요소 인증(2FA)이 아니다.",
      "question_en": "Since both passwords and security questions belong to the 'something you know' category, using them together does not constitute true two-factor authentication (2FA).",
      "hint_ko": "인증의 세 가지 요소(지식, 소유, 생체)를 생각해 보세요.",
      "hint_en": "Consider the three authentication factors: something you know, have, and are.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Multi-Factor Authentication (MFA)",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "이 문장은 사실입니다. 진정한 2FA는 서로 다른 범주의 인증 요소를 결합해야 합니다. 패스워드와 보안 질문은 모두 '지식(knowledge)' 요소이므로, 이는 2단계(two-step)이지만 2요소(two-factor)는 아닙니다.",
          "rationale_en": "This statement is correct. True 2FA requires combining factors from different categories. Both passwords and security questions are 'knowledge' factors, making this two-step but not two-factor.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "다중 인증(MFA)의 핵심은 서로 다른 범주(지식, 소유, 생체)의 요소를 결합하는 것입니다. 패스워드와 보안 질문은 같은 '지식' 범주에 속하므로 진정한 2FA가 아닙니다. 진정한 2FA의 예시는 패스워드(지식)와 OTP 토큰(소유) 또는 지문(생체)의 조합입니다.",
          "rationale_en": "The core of MFA is combining factors from different categories (knowledge, possession, biometrics). Passwords and security questions belong to the same 'knowledge' category, so they don't constitute true 2FA. Examples of true 2FA include password (knowledge) with OTP token (possession) or fingerprint (biometrics).",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "RBAC(Role-Based Access Control)에서 '권한 누적(Privilege Creep)'이 발생하는 이유는 무엇인가?",
      "question_en": "Why does 'privilege creep' occur in RBAC (Role-Based Access Control) systems?",
      "hint_ko": "직원이 조직 내에서 부서를 이동하거나 역할이 변경될 때 어떤 일이 발생하는지 생각해 보세요.",
      "hint_en": "Think about what happens when employees transfer between departments or change roles within an organization.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Role-Based Access Control (RBAC)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "RBAC 시스템 자체의 기술적 결함으로 인해 권한이 자동으로 추가되기 때문이다",
          "text_en": "Because technical flaws in the RBAC system automatically add permissions",
          "rationale_ko": "권한 누적은 RBAC 시스템의 기술적 결함이 아니라 관리 프로세스의 문제입니다. 시스템이 자동으로 권한을 추가하는 것이 아니라, 관리자가 새 역할을 부여할 때 이전 역할의 권한을 제거하지 않는 관리 소홀에서 비롯됩니다.",
          "rationale_en": "Privilege creep is not due to technical flaws in the RBAC system but rather management process issues. The system doesn't automatically add permissions; it results from administrators failing to remove permissions from previous roles when assigning new ones.",
          "isCorrect": false
        },
        {
          "text_ko": "직원이 부서 이동이나 역할 변경 시 새로운 권한은 부여받지만, 이전 역할의 불필요한 권한이 회수되지 않기 때문이다",
          "text_en": "Because employees receive new permissions when transferring or changing roles, but unnecessary permissions from previous roles are not revoked",
          "rationale_ko": "권한 누적의 핵심 원인은 부서 이동이나 승진 시 이전 역할의 권한을 제거하지 않고 새 역할의 권한만 추가하는 것입니다. 시간이 지나면 직원은 현재 업무에 불필요한 과도한 권한을 갖게 되어 최소 권한 원칙을 위반합니다.",
          "rationale_en": "The core cause of privilege creep is adding permissions for new roles without removing permissions from previous roles during transfers or promotions. Over time, employees accumulate excessive permissions unnecessary for their current duties, violating the principle of least privilege.",
          "isCorrect": true
        },
        {
          "text_ko": "RBAC에서는 상위 역할이 하위 역할의 모든 권한을 자동으로 상속하기 때문이다",
          "text_en": "Because in RBAC, higher roles automatically inherit all permissions of lower roles",
          "rationale_ko": "역할 계층에서의 권한 상속은 RBAC의 정상적인 설계 기능이며, 이것 자체가 권한 누적은 아닙니다. 권한 누적은 역할 변경 시 이전 역할 권한의 회수 실패에서 발생하는 운영상의 문제입니다.",
          "rationale_en": "Permission inheritance in role hierarchies is a normal RBAC design feature, not privilege creep itself. Privilege creep is an operational issue arising from failure to revoke previous role permissions during role changes.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "OAuth 2.0에서 인가 코드(Authorization Code)를 클라이언트 측이 아닌 서버 측에서 액세스 토큰으로 교환하는 이유는 무엇인가?",
      "question_en": "Why is the authorization code exchanged for an access token on the server side rather than the client side in OAuth 2.0?",
      "hint_ko": "브라우저(클라이언트 측)에서 실행되는 코드의 보안 한계를 생각해 보세요.",
      "hint_en": "Consider the security limitations of code running in the browser (client side).",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "OAuth 2.0 and Delegated Authorization",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "서버 측에서 교환하면 클라이언트 시크릿(client_secret)이 브라우저에 노출되지 않아 액세스 토큰의 안전한 발급이 가능하기 때문이다",
          "text_en": "Because exchanging on the server side prevents the client_secret from being exposed in the browser, enabling secure issuance of access tokens",
          "rationale_ko": "인가 코드를 액세스 토큰으로 교환하려면 client_secret이 필요합니다. 이 과정을 브라우저에서 수행하면 client_secret이 JavaScript 소스 코드나 네트워크 트래픽에 노출됩니다. 서버 측에서 교환하면 client_secret이 안전하게 보호되고, 액세스 토큰도 브라우저에 직접 노출되지 않습니다.",
          "rationale_en": "Exchanging the authorization code for an access token requires the client_secret. If this is done in the browser, the client_secret would be exposed in JavaScript source code or network traffic. Server-side exchange keeps the client_secret secure and prevents direct exposure of the access token to the browser.",
          "isCorrect": true
        },
        {
          "text_ko": "OAuth 2.0 표준이 서버 측 교환만 허용하기 때문이다",
          "text_en": "Because the OAuth 2.0 standard only allows server-side exchange",
          "rationale_ko": "OAuth 2.0은 Implicit Grant 같은 클라이언트 측 플로우도 정의하고 있습니다 (현재는 보안 이유로 권장되지 않음). 서버 측 교환이 선호되는 이유는 표준의 제한이 아니라 보안상의 이점 때문입니다.",
          "rationale_en": "OAuth 2.0 also defines client-side flows like Implicit Grant (though now deprecated for security reasons). Server-side exchange is preferred for its security benefits, not because of standard limitations.",
          "isCorrect": false
        },
        {
          "text_ko": "서버 측 교환이 네트워크 지연(latency)을 줄여주기 때문이다",
          "text_en": "Because server-side exchange reduces network latency",
          "rationale_ko": "서버 측 교환은 오히려 추가적인 네트워크 홉(서버 → 인가 서버)을 발생시킵니다. 서버 측 교환의 목적은 성능이 아니라 클라이언트 시크릿과 액세스 토큰의 보안을 위한 것입니다.",
          "rationale_en": "Server-side exchange actually introduces an additional network hop (server → authorization server). The purpose of server-side exchange is security of the client secret and access token, not performance.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "strncpy()는 복사할 바이트 수를 제한하지만, 소스 문자열이 지정된 크기 이상이면 null 종료 문자(\\0)를 자동으로 추가하지 않아 여전히 보안 문제를 일으킬 수 있다.",
      "question_en": "strncpy() limits the number of bytes copied, but if the source string equals or exceeds the specified size, it does not automatically append a null terminator (\\0), which can still cause security issues.",
      "hint_ko": "strncpy()가 문자열 끝에 null 종료 문자를 항상 추가하는지 확인해 보세요.",
      "hint_en": "Check whether strncpy() always appends a null terminator at the end of the string.",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Buffer Overflow Attacks",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "이 문장은 사실입니다. strncpy()는 n바이트만 복사하지만, 소스 문자열이 n 이상이면 대상 버퍼에 null 종료 문자를 추가하지 않습니다. 이로 인해 후속 문자열 함수가 버퍼를 초과하여 읽거나 정보가 유출될 수 있습니다.",
          "rationale_en": "This statement is factually correct. strncpy() copies only n bytes, but if the source string is n or longer, it does not add a null terminator to the destination buffer. This can cause subsequent string functions to read beyond the buffer or leak information.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "strncpy()의 이 동작은 C 표준에 명시된 것입니다. 소스 문자열 길이가 n 이상이면 null 종료 없이 정확히 n바이트만 복사합니다. 이후 strlen()이나 printf() 같은 함수가 null 종료 문자를 찾아 버퍼를 벗어나 읽게 되어 정보 유출이나 크래시가 발생할 수 있습니다.",
          "rationale_en": "This behavior of strncpy() is specified in the C standard. If the source string length equals or exceeds n, it copies exactly n bytes without null termination. Functions like strlen() or printf() then search for a null terminator beyond the buffer, potentially causing information leaks or crashes.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "-fstack-protector 옵션은 스택 카나리(Stack Canary)를 삽입하여 스택 기반 버퍼 오버플로우에서 반환 주소 변조를 탐지하지만, 힙 오버플로우나 카나리 값 유출 공격에는 대응하지 못한다.",
      "question_en": "The -fstack-protector option inserts stack canaries to detect return address tampering in stack-based buffer overflows, but cannot defend against heap overflows or canary value leak attacks.",
      "hint_ko": "스택 카나리(Stack Canary)가 보호하는 영역과 보호하지 못하는 영역을 생각해 보세요.",
      "hint_en": "Consider which areas stack canaries protect and which they don't.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Memory Safety and ASLR",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "스택 카나리는 함수의 반환 주소 앞에 무작위 값을 배치하여, 버퍼 오버플로우로 반환 주소가 덮어쓰이면 카나리 값 변경을 감지합니다. 그러나 힙 영역에는 카나리가 없으므로 힙 오버플로우에는 무력하고, 정보 유출 취약점으로 카나리 값이 노출되면 우회될 수 있습니다.",
          "rationale_en": "Stack canaries place random values before the function return address, detecting if the return address is overwritten by buffer overflow through canary value changes. However, there are no canaries in the heap area, making them powerless against heap overflows, and they can be bypassed if the canary value is leaked through information disclosure vulnerabilities.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 정확합니다. 스택 프로텍터의 보호 범위는 스택 기반 오버플로우에서의 반환 주소 보호에 한정됩니다. 힙 오버플로우, 포맷 스트링 공격, 카나리 값 유출 등 다른 공격 벡터에 대한 방어는 ASLR, NX 비트 등 추가적인 보호 메커니즘이 필요합니다.",
          "rationale_en": "This statement is accurate. The protection scope of stack protector is limited to return address protection in stack-based overflows. Additional protection mechanisms like ASLR and NX bit are needed to defend against other attack vectors such as heap overflows, format string attacks, and canary value leaks.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "TOCTOU(Time-of-Check to Time-of-Use) 취약점에서 검사(Check)와 사용(Use) 사이의 시간 창(window)을 공격자가 악용하는 방식은 무엇인가?",
      "question_en": "In a TOCTOU (Time-of-Check to Time-of-Use) vulnerability, how does an attacker exploit the time window between the check and use?",
      "hint_ko": "파일 시스템에서 심볼릭 링크(symlink)가 가리키는 대상을 변경할 수 있다는 점을 생각해 보세요.",
      "hint_en": "Consider that the target of a symbolic link (symlink) in a file system can be changed.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Race Conditions and TOCTOU",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "검사 시점과 사용 시점 사이에 대상 리소스(예: 파일)를 다른 것으로 교체하여, 검사를 통과한 것과 다른 리소스가 사용되게 한다",
          "text_en": "Replace the target resource (e.g., file) between the check and use, causing a different resource to be used than what passed the check",
          "rationale_ko": "TOCTOU 공격에서 프로그램이 파일 접근 권한을 확인(access())한 후 파일을 열기(open()) 전에, 공격자가 심볼릭 링크를 변경하여 다른 파일(예: /etc/shadow)을 가리키게 합니다. 프로그램은 검사를 통과했다고 판단하고 실제로는 권한이 없는 파일에 접근하게 됩니다.",
          "rationale_en": "In a TOCTOU attack, after a program checks file access permissions (access()) but before opening the file (open()), the attacker changes a symbolic link to point to a different file (e.g., /etc/shadow). The program believes the check passed and accesses a file it shouldn't have permission to access.",
          "isCorrect": true
        },
        {
          "text_ko": "검사와 사용 사이에 네트워크 패킷을 가로채서 변조한다",
          "text_en": "Intercept and modify network packets between the check and use",
          "rationale_ko": "TOCTOU 취약점은 주로 로컬 파일 시스템이나 공유 메모리에서 발생하는 경쟁 조건입니다. 네트워크 패킷 가로채기는 중간자 공격(Man-in-the-Middle)에 해당하며, TOCTOU와는 다른 공격 유형입니다.",
          "rationale_en": "TOCTOU vulnerabilities are race conditions primarily occurring in local file systems or shared memory. Network packet interception is a Man-in-the-Middle attack, which is a different attack type from TOCTOU.",
          "isCorrect": false
        },
        {
          "text_ko": "검사 함수 자체의 버그를 이용하여 검사를 우회한다",
          "text_en": "Exploit bugs in the check function itself to bypass the check",
          "rationale_ko": "TOCTOU 취약점은 검사 함수의 버그가 아니라 검사와 사용 사이의 시간 차이를 악용합니다. 검사 자체는 정상적으로 수행되지만, 검사 이후 사용 전에 대상이 변경되는 것이 핵심입니다.",
          "rationale_en": "TOCTOU vulnerabilities exploit the time gap between check and use, not bugs in the check function. The check itself is performed correctly, but the target changes between the check and the use.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "웹 애플리케이션에서 보안을 위한 입력 검증은 반드시 서버 측에서 수행해야 하며, 클라이언트 측 검증만으로는 보안을 확보할 수 없다.",
      "question_en": "Input validation for security in web applications must be performed on the server side, and client-side validation alone cannot ensure security.",
      "hint_ko": "사용자가 브라우저를 우회할 수 있는 방법을 생각해 보세요.",
      "hint_en": "Consider how users can bypass the browser.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Input Validation and Sanitization",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "클라이언트 측 JavaScript 검증은 공격자가 브라우저 개발자 도구나 프록시 도구(예: Burp Suite)를 사용하여 쉽게 우회할 수 있습니다. 서버 측 검증은 모든 요청이 반드시 거치는 지점이므로 우회가 불가능하며, 보안의 근본적인 방어선입니다.",
          "rationale_en": "Client-side JavaScript validation can be easily bypassed using browser developer tools or proxy tools (e.g., Burp Suite). Server-side validation is a point that all requests must pass through, making it impossible to bypass and serving as the fundamental line of defense.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 정확합니다. 클라이언트 측 코드는 사용자가 완전히 제어할 수 있어 보안 목적으로는 신뢰할 수 없습니다. 서버 측 검증이 필수이며, 클라이언트 측 검증은 사용자 경험 향상을 위한 보조 수단일 뿐입니다.",
          "rationale_en": "This statement is correct. Client-side code is fully controllable by users and cannot be trusted for security purposes. Server-side validation is mandatory, and client-side validation is merely a supplementary measure for user experience.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "Unix 시스템에서 setuid 비트가 설정된 프로그램이 보안 위험이 될 수 있는 이유는 무엇인가?",
      "question_en": "Why can a program with the setuid bit set on a Unix system pose a security risk?",
      "hint_ko": "setuid 프로그램이 실행될 때 어떤 사용자 권한으로 동작하는지 생각해 보세요.",
      "hint_en": "Think about which user's privileges a setuid program runs with when executed.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Privilege Escalation",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "setuid 프로그램은 파일 소유자의 권한으로 실행되므로, 취약점이 있으면 공격자가 높은 권한을 획득할 수 있기 때문이다",
          "text_en": "Because setuid programs run with the file owner's privileges, so vulnerabilities can allow attackers to gain elevated privileges",
          "rationale_ko": "setuid 비트가 설정된 프로그램은 실행하는 사용자가 아닌 파일 소유자의 권한으로 동작합니다. root 소유의 setuid 프로그램에 버퍼 오버플로우 같은 취약점이 있으면, 일반 사용자가 이를 악용하여 root 권한으로 임의 코드를 실행할 수 있습니다.",
          "rationale_en": "Programs with the setuid bit run with the file owner's privileges, not the executing user's. If a root-owned setuid program has vulnerabilities like buffer overflow, a regular user can exploit it to execute arbitrary code with root privileges.",
          "isCorrect": true
        },
        {
          "text_ko": "setuid 프로그램은 네트워크 포트를 열어 외부 공격에 노출되기 때문이다",
          "text_en": "Because setuid programs open network ports, exposing them to external attacks",
          "rationale_ko": "setuid 비트는 네트워크 포트와 직접적인 관련이 없습니다. setuid의 보안 위험은 프로그램이 파일 소유자(보통 root)의 권한으로 실행된다는 점에서 비롯되며, 이를 통한 권한 상승이 핵심 문제입니다.",
          "rationale_en": "The setuid bit has no direct relationship to network ports. The security risk of setuid comes from the program running with the file owner's (usually root) privileges, with privilege escalation being the core concern.",
          "isCorrect": false
        },
        {
          "text_ko": "setuid 프로그램은 실행 시 시스템 로그를 남기지 않아 추적이 불가능하기 때문이다",
          "text_en": "Because setuid programs do not leave system logs when executed, making them untraceable",
          "rationale_ko": "setuid 프로그램도 시스템 로그에 기록될 수 있으며, audit 시스템을 통해 추적이 가능합니다. 보안 위험의 핵심은 로그 부재가 아니라 권한 상승 가능성에 있습니다.",
          "rationale_en": "setuid programs can be recorded in system logs and tracked through audit systems. The core security risk is not the absence of logs but the possibility of privilege escalation.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "chroot, 컨테이너(Container), 가상 머신(VM)을 격리 수준이 낮은 것부터 높은 순서로 올바르게 나열한 것은?",
      "question_en": "Which is the correct order of chroot, containers, and virtual machines (VMs) from lowest to highest isolation level?",
      "hint_ko": "각 기술이 공유하는 자원의 범위를 생각해 보세요. 커널을 공유하는지 여부가 핵심입니다.",
      "hint_en": "Consider the scope of resources each technology shares. Whether they share the kernel is key.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Sandboxing and Isolation",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "chroot → 컨테이너 → 가상 머신",
          "text_en": "chroot → Container → VM",
          "rationale_ko": "chroot는 파일 시스템 경로만 제한하며 프로세스, 네트워크 등은 격리하지 않습니다. 컨테이너는 커널은 공유하지만 네임스페이스와 cgroups로 프로세스, 네트워크, 파일 시스템을 격리합니다. VM은 하이퍼바이저 위에서 별도의 커널을 실행하여 가장 강력한 격리를 제공합니다.",
          "rationale_en": "chroot only restricts file system paths and does not isolate processes or network. Containers share the kernel but isolate processes, network, and file systems via namespaces and cgroups. VMs run separate kernels on a hypervisor, providing the strongest isolation.",
          "isCorrect": true
        },
        {
          "text_ko": "컨테이너 → chroot → 가상 머신",
          "text_en": "Container → chroot → VM",
          "rationale_ko": "컨테이너는 네임스페이스와 cgroups를 활용하여 chroot보다 훨씬 강력한 격리를 제공합니다. chroot는 단순히 파일 시스템 루트를 변경할 뿐이므로 컨테이너보다 격리 수준이 낮습니다.",
          "rationale_en": "Containers use namespaces and cgroups to provide much stronger isolation than chroot. chroot simply changes the file system root, so its isolation level is lower than containers.",
          "isCorrect": false
        },
        {
          "text_ko": "가상 머신 → 컨테이너 → chroot",
          "text_en": "VM → Container → chroot",
          "rationale_ko": "이 순서는 격리 수준이 높은 것부터 나열한 것으로, 질문에서 요구한 '낮은 것부터 높은 순서'와 반대입니다.",
          "rationale_en": "This order lists from highest to lowest isolation, which is the reverse of what the question asks for ('lowest to highest').",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "MAC(Mandatory Access Control)에서는 root 사용자도 정책에 의해 접근이 제한될 수 있지만, DAC(Discretionary Access Control)에서는 root가 모든 접근 제어를 우회할 수 있다.",
      "question_en": "In MAC (Mandatory Access Control), even the root user can be restricted by policy, whereas in DAC (Discretionary Access Control), root can bypass all access controls.",
      "hint_ko": "DAC와 MAC에서 '누가 접근 정책을 결정하는가'의 차이를 생각해 보세요.",
      "hint_en": "Think about the difference in 'who determines access policy' between DAC and MAC.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Mandatory Access Control (SELinux, AppArmor)",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "DAC에서는 파일 소유자가 접근 권한을 설정하며, root는 이러한 제한을 무시할 수 있습니다. 반면 MAC(예: SELinux)에서는 시스템 관리자가 설정한 보안 정책이 모든 사용자에게 강제 적용되며, root도 정책에 의해 제한됩니다. 이것이 MAC이 더 강력한 보안을 제공하는 이유입니다.",
          "rationale_en": "In DAC, file owners set access permissions, and root can override these restrictions. In MAC (e.g., SELinux), security policies set by system administrators are enforced for all users, including root. This is why MAC provides stronger security.",
          "isCorrect": true
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "이 문장은 정확합니다. MAC의 핵심 특징은 커널 수준에서 보안 정책을 강제하여 root를 포함한 모든 프로세스가 정책을 따르게 하는 것입니다. SELinux에서 root 권한의 httpd 프로세스도 정책에 허용되지 않은 파일에 접근할 수 없는 것이 좋은 예입니다.",
          "rationale_en": "This statement is accurate. MAC's core feature is enforcing security policies at the kernel level so all processes, including root, must comply. A good example is how in SELinux, even a root-privileged httpd process cannot access files not permitted by policy.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "최소 권한 원칙(Principle of Least Privilege)에서 '시간적 차원(temporal dimension)'이란 무엇을 의미하는가?",
      "question_en": "What does the 'temporal dimension' mean in the Principle of Least Privilege?",
      "hint_ko": "권한이 '항상' 부여되어야 하는지, 아니면 '필요한 시점에만' 부여되어야 하는지를 생각해 보세요.",
      "hint_en": "Consider whether privileges should be granted 'permanently' or only 'when needed.'",
      "topic": "computerSecurity",
      "difficulty": "hard",
      "concept": "Principle of Least Privilege",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "권한은 업무 수행에 필요한 시점에만 부여하고, 작업이 완료되면 즉시 회수해야 한다는 의미이다",
          "text_en": "Privileges should be granted only when needed for task execution and immediately revoked upon completion",
          "rationale_ko": "최소 권한 원칙의 시간적 차원은 'Just-In-Time(JIT) Access' 개념을 포함합니다. 사용자에게 필요한 최소한의 권한을 부여할 뿐만 아니라, 그 권한이 필요한 시간 동안만 활성화해야 합니다. 예를 들어 데이터베이스 관리자가 유지보수 시에만 DBA 권한을 받고, 작업 후 자동으로 회수되는 방식입니다.",
          "rationale_en": "The temporal dimension of least privilege includes the Just-In-Time (JIT) Access concept. Beyond granting users the minimum necessary privileges, those privileges should only be active for the duration they're needed. For example, a database administrator receives DBA privileges only during maintenance and they are automatically revoked afterward.",
          "isCorrect": true
        },
        {
          "text_ko": "오래된 사용자 계정은 자동으로 삭제해야 한다는 의미이다",
          "text_en": "Old user accounts should be automatically deleted",
          "rationale_ko": "오래된 계정 삭제는 계정 관리 정책의 일부이지만, 최소 권한 원칙의 시간적 차원과는 다른 개념입니다. 시간적 차원은 활성 사용자의 권한을 필요한 시점에만 부여하고 사용 후 회수하는 것을 의미합니다.",
          "rationale_en": "Deleting old accounts is part of account management policy but is a different concept from the temporal dimension of least privilege. The temporal dimension refers to granting active users privileges only when needed and revoking them after use.",
          "isCorrect": false
        },
        {
          "text_ko": "보안 정책을 정기적으로 갱신해야 한다는 의미이다",
          "text_en": "Security policies should be regularly updated",
          "rationale_ko": "보안 정책의 정기적 갱신은 좋은 관행이지만, 최소 권한 원칙의 시간적 차원을 설명하는 것은 아닙니다. 시간적 차원은 개별 권한의 부여와 회수 시점에 관한 것입니다.",
          "rationale_en": "Regular security policy updates are good practice but do not describe the temporal dimension of least privilege. The temporal dimension concerns the timing of granting and revoking individual privileges.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "심층 방어(Defense in Depth) 전략에서 보안 계층을 추가하면 항상 보안이 향상되는가?",
      "question_en": "In a Defense in Depth strategy, does adding more security layers always improve security?",
      "hint_ko": "보안 계층이 늘어나면 복잡성도 함께 증가한다는 점을 생각해 보세요.",
      "hint_en": "Consider that increasing security layers also increases complexity.",
      "topic": "computerSecurity",
      "difficulty": "medium",
      "concept": "Defense in Depth",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "항상 그렇다. 보안 계층이 많을수록 공격자가 뚫어야 할 장벽이 많아지므로 반드시 더 안전해진다",
          "text_en": "Always. More security layers mean more barriers for attackers to breach, so it is necessarily more secure",
          "rationale_ko": "보안 계층을 추가하면 시스템 복잡성이 증가하여 설정 오류의 가능성이 높아집니다. 또한 성능 저하, 관리 비용 증가, 보안 도구 간의 상호 간섭 등의 문제가 발생할 수 있습니다. 복잡한 시스템은 오히려 새로운 취약점을 만들 수 있습니다.",
          "rationale_en": "Adding security layers increases system complexity, raising the possibility of configuration errors. It can also cause performance degradation, increased management costs, and interference between security tools. Complex systems can actually create new vulnerabilities.",
          "isCorrect": false
        },
        {
          "text_ko": "반드시 그렇지는 않다. 과도한 보안 계층은 복잡성을 증가시켜 설정 오류나 운영 문제를 일으킬 수 있으며, 이는 새로운 취약점이 될 수 있다",
          "text_en": "Not necessarily. Excessive security layers can increase complexity, leading to configuration errors or operational issues, which can become new vulnerabilities",
          "rationale_ko": "심층 방어는 효과적인 전략이지만, 각 계층이 명확한 위협에 대응해야 합니다. 무분별하게 계층을 추가하면 관리 복잡성이 증가하고, 잘못 설정된 보안 도구는 오히려 보안을 약화시킵니다. 효과적인 심층 방어는 양보다 질, 즉 각 계층의 적절한 구성과 관리가 중요합니다.",
          "rationale_en": "Defense in depth is an effective strategy, but each layer should address specific threats. Indiscriminately adding layers increases management complexity, and misconfigured security tools can actually weaken security. Effective defense in depth prioritizes quality over quantity—proper configuration and management of each layer.",
          "isCorrect": true
        }
      ]
    },
    {
      "question_ko": "STRIDE 위협 모델링에서 각 글자가 나타내는 위협 유형은 무엇인가?",
      "question_en": "What threat types do the letters in STRIDE threat modeling represent?",
      "hint_ko": "STRIDE의 각 글자는 서로 다른 보안 속성(예: 인증, 무결성 등)에 대한 위협을 나타냅니다.",
      "hint_en": "Each letter in STRIDE represents a threat to a different security property (e.g., authentication, integrity).",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Threat Modeling (STRIDE)",
      "questionType": "conceptual",
      "answerOptions": [
        {
          "text_ko": "Spoofing(위장), Tampering(변조), Repudiation(부인), Information Disclosure(정보 유출), Denial of Service(서비스 거부), Elevation of Privilege(권한 상승)",
          "text_en": "Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege",
          "rationale_ko": "STRIDE는 Microsoft가 제안한 위협 모델링 프레임워크로, 각 글자가 하나의 위협 유형을 나타냅니다. Spoofing은 인증에, Tampering은 무결성에, Repudiation은 부인 방지에, Information Disclosure는 기밀성에, DoS는 가용성에, Elevation of Privilege는 인가에 대한 위협입니다.",
          "rationale_en": "STRIDE is a threat modeling framework proposed by Microsoft, where each letter represents one threat type. Spoofing threatens authentication, Tampering threatens integrity, Repudiation threatens non-repudiation, Information Disclosure threatens confidentiality, DoS threatens availability, and Elevation of Privilege threatens authorization.",
          "isCorrect": true
        },
        {
          "text_ko": "Scanning(스캐닝), Tracking(추적), Ransomware(랜섬웨어), Injection(인젝션), DDoS(분산 서비스 거부), Exploitation(익스플로잇)",
          "text_en": "Scanning, Tracking, Ransomware, Injection, DDoS, Exploitation",
          "rationale_ko": "이것은 STRIDE의 올바른 의미가 아닙니다. 이 용어들은 구체적인 공격 기법이나 도구를 나타내며, STRIDE는 추상적인 위협 카테고리를 분류하는 프레임워크입니다. STRIDE의 정확한 의미는 Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege입니다.",
          "rationale_en": "These are not the correct meanings of STRIDE. These terms represent specific attack techniques or tools, while STRIDE is a framework for classifying abstract threat categories. The correct meanings are Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, and Elevation of Privilege.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "다음 중 악성코드(Malware) 유형과 그 특성을 올바르게 연결한 것은?",
      "question_en": "Which of the following correctly matches malware types with their characteristics?",
      "hint_ko": "각 악성코드가 전파되기 위해 사용자의 행동이 필요한지 여부를 기준으로 구분해 보세요.",
      "hint_en": "Distinguish based on whether each malware requires user action to spread.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Malware Types and Behavior",
      "questionType": "comparative",
      "answerOptions": [
        {
          "text_ko": "바이러스는 사용자의 실행이 필요하고, 웜은 자가 전파되며, 트로이 목마는 정상 프로그램으로 위장한다",
          "text_en": "Viruses require user execution, worms self-propagate, and trojans disguise as legitimate programs",
          "rationale_ko": "바이러스는 다른 프로그램에 자신을 삽입하고 사용자가 감염된 파일을 실행해야 전파됩니다. 웜은 네트워크 취약점을 이용하여 사용자 개입 없이 스스로 전파됩니다. 트로이 목마는 유용한 프로그램으로 위장하여 사용자가 자발적으로 설치하도록 유도합니다.",
          "rationale_en": "Viruses insert themselves into other programs and spread when users execute infected files. Worms exploit network vulnerabilities to self-propagate without user intervention. Trojans disguise as useful programs to trick users into voluntarily installing them.",
          "isCorrect": true
        },
        {
          "text_ko": "바이러스는 자가 전파되고, 웜은 사용자의 실행이 필요하며, 트로이 목마는 암호화하여 금전을 요구한다",
          "text_en": "Viruses self-propagate, worms require user execution, and trojans encrypt and demand ransom",
          "rationale_ko": "바이러스와 웜의 특성이 뒤바뀌어 있습니다. 바이러스는 사용자 실행이 필요하고 웜이 자가 전파됩니다. 또한 암호화 후 금전을 요구하는 것은 랜섬웨어(Ransomware)의 특성이며, 트로이 목마와는 다른 유형입니다.",
          "rationale_en": "The characteristics of viruses and worms are swapped. Viruses require user execution while worms self-propagate. Also, encrypting and demanding ransom is a characteristic of ransomware, which is a different type from trojans.",
          "isCorrect": false
        },
        {
          "text_ko": "세 유형 모두 네트워크를 통해 자동으로 전파되며, 사용자 개입이 필요 없다",
          "text_en": "All three types automatically spread through networks without user intervention",
          "rationale_ko": "네트워크를 통해 자동 전파되는 것은 웜만의 특성입니다. 바이러스는 사용자가 감염된 파일을 실행해야 하고, 트로이 목마는 사용자가 직접 설치해야 합니다. 각 유형의 전파 방식이 서로 다른 것이 핵심 구분점입니다.",
          "rationale_en": "Automatic network propagation is a characteristic unique to worms. Viruses require users to execute infected files, and trojans require users to install them. The different propagation methods are the key distinguishing factor between these types.",
          "isCorrect": false
        }
      ]
    },
    {
      "question_ko": "보안 인식 교육(Security Awareness Training)을 실시하면 피싱(Phishing) 위험을 완전히 제거할 수 있다.",
      "question_en": "Conducting security awareness training completely eliminates phishing risk.",
      "hint_ko": "사람의 인지적 한계와 고도화된 피싱 기법을 함께 고려해 보세요.",
      "hint_en": "Consider the cognitive limitations of humans alongside sophisticated phishing techniques.",
      "topic": "computerSecurity",
      "difficulty": "easy",
      "concept": "Phishing and Social Engineering",
      "questionType": "trap",
      "answerOptions": [
        {
          "text_ko": "True",
          "text_en": "True",
          "rationale_ko": "보안 인식 교육은 피싱 클릭률을 크게 줄일 수 있지만, 인간의 인지적 편향(긴급성 편향, 권위에 대한 복종 등)은 교육으로 완전히 제거할 수 없습니다. 또한 스피어 피싱(Spear Phishing)처럼 고도로 개인화된 공격은 훈련받은 직원도 속일 수 있습니다.",
          "rationale_en": "Security awareness training can significantly reduce phishing click rates, but cognitive biases (urgency bias, obedience to authority, etc.) cannot be completely eliminated through training. Highly personalized attacks like spear phishing can deceive even trained employees.",
          "isCorrect": false
        },
        {
          "text_ko": "False",
          "text_en": "False",
          "rationale_ko": "보안 인식 교육은 피싱 공격의 성공률을 낮추는 중요한 대책이지만, 인간의 실수 가능성을 0으로 만들 수는 없습니다. 이메일 필터링(DMARC, SPF, DKIM), 다중 인증(MFA), URL 검사 도구 등 기술적 대책을 함께 사용하여 인간의 실수에 대한 안전망을 구축해야 합니다.",
          "rationale_en": "Security awareness training is an important measure to reduce phishing success rates, but it cannot reduce the possibility of human error to zero. Technical countermeasures like email filtering (DMARC, SPF, DKIM), MFA, and URL inspection tools should be used together to create a safety net for human errors.",
          "isCorrect": true
        }
      ]
    }
  ]